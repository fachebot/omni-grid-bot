// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/fachebot/omni-grid-bot/internal/ent/grid"
	"github.com/fachebot/omni-grid-bot/internal/ent/matchedtrade"
	"github.com/fachebot/omni-grid-bot/internal/ent/order"
	"github.com/fachebot/omni-grid-bot/internal/ent/predicate"
	"github.com/fachebot/omni-grid-bot/internal/ent/strategy"
	"github.com/fachebot/omni-grid-bot/internal/ent/syncprogress"
	"github.com/shopspring/decimal"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeGrid         = "Grid"
	TypeMatchedTrade = "MatchedTrade"
	TypeOrder        = "Order"
	TypeStrategy     = "Strategy"
	TypeSyncProgress = "SyncProgress"
)

// GridMutation represents an operation that mutates the Grid nodes in the graph.
type GridMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	create_time          *time.Time
	update_time          *time.Time
	strategyId           *string
	exchange             *string
	symbol               *string
	account              *string
	level                *int
	addlevel             *int
	price                *decimal.Decimal
	quantity             *decimal.Decimal
	buyClientOrderId     *int64
	addbuyClientOrderId  *int64
	sellClientOrderId    *int64
	addsellClientOrderId *int64
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*Grid, error)
	predicates           []predicate.Grid
}

var _ ent.Mutation = (*GridMutation)(nil)

// gridOption allows management of the mutation configuration using functional options.
type gridOption func(*GridMutation)

// newGridMutation creates new mutation for the Grid entity.
func newGridMutation(c config, op Op, opts ...gridOption) *GridMutation {
	m := &GridMutation{
		config:        c,
		op:            op,
		typ:           TypeGrid,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGridID sets the ID field of the mutation.
func withGridID(id int) gridOption {
	return func(m *GridMutation) {
		var (
			err   error
			once  sync.Once
			value *Grid
		)
		m.oldValue = func(ctx context.Context) (*Grid, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Grid.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGrid sets the old Grid of the mutation.
func withGrid(node *Grid) gridOption {
	return func(m *GridMutation) {
		m.oldValue = func(context.Context) (*Grid, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GridMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GridMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GridMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GridMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Grid.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *GridMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *GridMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Grid entity.
// If the Grid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *GridMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *GridMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *GridMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Grid entity.
// If the Grid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *GridMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStrategyId sets the "strategyId" field.
func (m *GridMutation) SetStrategyId(s string) {
	m.strategyId = &s
}

// StrategyId returns the value of the "strategyId" field in the mutation.
func (m *GridMutation) StrategyId() (r string, exists bool) {
	v := m.strategyId
	if v == nil {
		return
	}
	return *v, true
}

// OldStrategyId returns the old "strategyId" field's value of the Grid entity.
// If the Grid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridMutation) OldStrategyId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrategyId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrategyId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrategyId: %w", err)
	}
	return oldValue.StrategyId, nil
}

// ResetStrategyId resets all changes to the "strategyId" field.
func (m *GridMutation) ResetStrategyId() {
	m.strategyId = nil
}

// SetExchange sets the "exchange" field.
func (m *GridMutation) SetExchange(s string) {
	m.exchange = &s
}

// Exchange returns the value of the "exchange" field in the mutation.
func (m *GridMutation) Exchange() (r string, exists bool) {
	v := m.exchange
	if v == nil {
		return
	}
	return *v, true
}

// OldExchange returns the old "exchange" field's value of the Grid entity.
// If the Grid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridMutation) OldExchange(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExchange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExchange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExchange: %w", err)
	}
	return oldValue.Exchange, nil
}

// ResetExchange resets all changes to the "exchange" field.
func (m *GridMutation) ResetExchange() {
	m.exchange = nil
}

// SetSymbol sets the "symbol" field.
func (m *GridMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *GridMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the Grid entity.
// If the Grid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *GridMutation) ResetSymbol() {
	m.symbol = nil
}

// SetAccount sets the "account" field.
func (m *GridMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the value of the "account" field in the mutation.
func (m *GridMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old "account" field's value of the Grid entity.
// If the Grid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount resets all changes to the "account" field.
func (m *GridMutation) ResetAccount() {
	m.account = nil
}

// SetLevel sets the "level" field.
func (m *GridMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *GridMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Grid entity.
// If the Grid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *GridMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *GridMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *GridMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetPrice sets the "price" field.
func (m *GridMutation) SetPrice(d decimal.Decimal) {
	m.price = &d
}

// Price returns the value of the "price" field in the mutation.
func (m *GridMutation) Price() (r decimal.Decimal, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Grid entity.
// If the Grid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridMutation) OldPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ResetPrice resets all changes to the "price" field.
func (m *GridMutation) ResetPrice() {
	m.price = nil
}

// SetQuantity sets the "quantity" field.
func (m *GridMutation) SetQuantity(d decimal.Decimal) {
	m.quantity = &d
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *GridMutation) Quantity() (r decimal.Decimal, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the Grid entity.
// If the Grid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridMutation) OldQuantity(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *GridMutation) ResetQuantity() {
	m.quantity = nil
}

// SetBuyClientOrderId sets the "buyClientOrderId" field.
func (m *GridMutation) SetBuyClientOrderId(i int64) {
	m.buyClientOrderId = &i
	m.addbuyClientOrderId = nil
}

// BuyClientOrderId returns the value of the "buyClientOrderId" field in the mutation.
func (m *GridMutation) BuyClientOrderId() (r int64, exists bool) {
	v := m.buyClientOrderId
	if v == nil {
		return
	}
	return *v, true
}

// OldBuyClientOrderId returns the old "buyClientOrderId" field's value of the Grid entity.
// If the Grid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridMutation) OldBuyClientOrderId(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuyClientOrderId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuyClientOrderId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuyClientOrderId: %w", err)
	}
	return oldValue.BuyClientOrderId, nil
}

// AddBuyClientOrderId adds i to the "buyClientOrderId" field.
func (m *GridMutation) AddBuyClientOrderId(i int64) {
	if m.addbuyClientOrderId != nil {
		*m.addbuyClientOrderId += i
	} else {
		m.addbuyClientOrderId = &i
	}
}

// AddedBuyClientOrderId returns the value that was added to the "buyClientOrderId" field in this mutation.
func (m *GridMutation) AddedBuyClientOrderId() (r int64, exists bool) {
	v := m.addbuyClientOrderId
	if v == nil {
		return
	}
	return *v, true
}

// ClearBuyClientOrderId clears the value of the "buyClientOrderId" field.
func (m *GridMutation) ClearBuyClientOrderId() {
	m.buyClientOrderId = nil
	m.addbuyClientOrderId = nil
	m.clearedFields[grid.FieldBuyClientOrderId] = struct{}{}
}

// BuyClientOrderIdCleared returns if the "buyClientOrderId" field was cleared in this mutation.
func (m *GridMutation) BuyClientOrderIdCleared() bool {
	_, ok := m.clearedFields[grid.FieldBuyClientOrderId]
	return ok
}

// ResetBuyClientOrderId resets all changes to the "buyClientOrderId" field.
func (m *GridMutation) ResetBuyClientOrderId() {
	m.buyClientOrderId = nil
	m.addbuyClientOrderId = nil
	delete(m.clearedFields, grid.FieldBuyClientOrderId)
}

// SetSellClientOrderId sets the "sellClientOrderId" field.
func (m *GridMutation) SetSellClientOrderId(i int64) {
	m.sellClientOrderId = &i
	m.addsellClientOrderId = nil
}

// SellClientOrderId returns the value of the "sellClientOrderId" field in the mutation.
func (m *GridMutation) SellClientOrderId() (r int64, exists bool) {
	v := m.sellClientOrderId
	if v == nil {
		return
	}
	return *v, true
}

// OldSellClientOrderId returns the old "sellClientOrderId" field's value of the Grid entity.
// If the Grid object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridMutation) OldSellClientOrderId(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSellClientOrderId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSellClientOrderId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSellClientOrderId: %w", err)
	}
	return oldValue.SellClientOrderId, nil
}

// AddSellClientOrderId adds i to the "sellClientOrderId" field.
func (m *GridMutation) AddSellClientOrderId(i int64) {
	if m.addsellClientOrderId != nil {
		*m.addsellClientOrderId += i
	} else {
		m.addsellClientOrderId = &i
	}
}

// AddedSellClientOrderId returns the value that was added to the "sellClientOrderId" field in this mutation.
func (m *GridMutation) AddedSellClientOrderId() (r int64, exists bool) {
	v := m.addsellClientOrderId
	if v == nil {
		return
	}
	return *v, true
}

// ClearSellClientOrderId clears the value of the "sellClientOrderId" field.
func (m *GridMutation) ClearSellClientOrderId() {
	m.sellClientOrderId = nil
	m.addsellClientOrderId = nil
	m.clearedFields[grid.FieldSellClientOrderId] = struct{}{}
}

// SellClientOrderIdCleared returns if the "sellClientOrderId" field was cleared in this mutation.
func (m *GridMutation) SellClientOrderIdCleared() bool {
	_, ok := m.clearedFields[grid.FieldSellClientOrderId]
	return ok
}

// ResetSellClientOrderId resets all changes to the "sellClientOrderId" field.
func (m *GridMutation) ResetSellClientOrderId() {
	m.sellClientOrderId = nil
	m.addsellClientOrderId = nil
	delete(m.clearedFields, grid.FieldSellClientOrderId)
}

// Where appends a list predicates to the GridMutation builder.
func (m *GridMutation) Where(ps ...predicate.Grid) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GridMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GridMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Grid, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GridMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GridMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Grid).
func (m *GridMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GridMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.create_time != nil {
		fields = append(fields, grid.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, grid.FieldUpdateTime)
	}
	if m.strategyId != nil {
		fields = append(fields, grid.FieldStrategyId)
	}
	if m.exchange != nil {
		fields = append(fields, grid.FieldExchange)
	}
	if m.symbol != nil {
		fields = append(fields, grid.FieldSymbol)
	}
	if m.account != nil {
		fields = append(fields, grid.FieldAccount)
	}
	if m.level != nil {
		fields = append(fields, grid.FieldLevel)
	}
	if m.price != nil {
		fields = append(fields, grid.FieldPrice)
	}
	if m.quantity != nil {
		fields = append(fields, grid.FieldQuantity)
	}
	if m.buyClientOrderId != nil {
		fields = append(fields, grid.FieldBuyClientOrderId)
	}
	if m.sellClientOrderId != nil {
		fields = append(fields, grid.FieldSellClientOrderId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GridMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case grid.FieldCreateTime:
		return m.CreateTime()
	case grid.FieldUpdateTime:
		return m.UpdateTime()
	case grid.FieldStrategyId:
		return m.StrategyId()
	case grid.FieldExchange:
		return m.Exchange()
	case grid.FieldSymbol:
		return m.Symbol()
	case grid.FieldAccount:
		return m.Account()
	case grid.FieldLevel:
		return m.Level()
	case grid.FieldPrice:
		return m.Price()
	case grid.FieldQuantity:
		return m.Quantity()
	case grid.FieldBuyClientOrderId:
		return m.BuyClientOrderId()
	case grid.FieldSellClientOrderId:
		return m.SellClientOrderId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GridMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case grid.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case grid.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case grid.FieldStrategyId:
		return m.OldStrategyId(ctx)
	case grid.FieldExchange:
		return m.OldExchange(ctx)
	case grid.FieldSymbol:
		return m.OldSymbol(ctx)
	case grid.FieldAccount:
		return m.OldAccount(ctx)
	case grid.FieldLevel:
		return m.OldLevel(ctx)
	case grid.FieldPrice:
		return m.OldPrice(ctx)
	case grid.FieldQuantity:
		return m.OldQuantity(ctx)
	case grid.FieldBuyClientOrderId:
		return m.OldBuyClientOrderId(ctx)
	case grid.FieldSellClientOrderId:
		return m.OldSellClientOrderId(ctx)
	}
	return nil, fmt.Errorf("unknown Grid field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GridMutation) SetField(name string, value ent.Value) error {
	switch name {
	case grid.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case grid.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case grid.FieldStrategyId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrategyId(v)
		return nil
	case grid.FieldExchange:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExchange(v)
		return nil
	case grid.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case grid.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case grid.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case grid.FieldPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case grid.FieldQuantity:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case grid.FieldBuyClientOrderId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuyClientOrderId(v)
		return nil
	case grid.FieldSellClientOrderId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSellClientOrderId(v)
		return nil
	}
	return fmt.Errorf("unknown Grid field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GridMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, grid.FieldLevel)
	}
	if m.addbuyClientOrderId != nil {
		fields = append(fields, grid.FieldBuyClientOrderId)
	}
	if m.addsellClientOrderId != nil {
		fields = append(fields, grid.FieldSellClientOrderId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GridMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case grid.FieldLevel:
		return m.AddedLevel()
	case grid.FieldBuyClientOrderId:
		return m.AddedBuyClientOrderId()
	case grid.FieldSellClientOrderId:
		return m.AddedSellClientOrderId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GridMutation) AddField(name string, value ent.Value) error {
	switch name {
	case grid.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case grid.FieldBuyClientOrderId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBuyClientOrderId(v)
		return nil
	case grid.FieldSellClientOrderId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSellClientOrderId(v)
		return nil
	}
	return fmt.Errorf("unknown Grid numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GridMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(grid.FieldBuyClientOrderId) {
		fields = append(fields, grid.FieldBuyClientOrderId)
	}
	if m.FieldCleared(grid.FieldSellClientOrderId) {
		fields = append(fields, grid.FieldSellClientOrderId)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GridMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GridMutation) ClearField(name string) error {
	switch name {
	case grid.FieldBuyClientOrderId:
		m.ClearBuyClientOrderId()
		return nil
	case grid.FieldSellClientOrderId:
		m.ClearSellClientOrderId()
		return nil
	}
	return fmt.Errorf("unknown Grid nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GridMutation) ResetField(name string) error {
	switch name {
	case grid.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case grid.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case grid.FieldStrategyId:
		m.ResetStrategyId()
		return nil
	case grid.FieldExchange:
		m.ResetExchange()
		return nil
	case grid.FieldSymbol:
		m.ResetSymbol()
		return nil
	case grid.FieldAccount:
		m.ResetAccount()
		return nil
	case grid.FieldLevel:
		m.ResetLevel()
		return nil
	case grid.FieldPrice:
		m.ResetPrice()
		return nil
	case grid.FieldQuantity:
		m.ResetQuantity()
		return nil
	case grid.FieldBuyClientOrderId:
		m.ResetBuyClientOrderId()
		return nil
	case grid.FieldSellClientOrderId:
		m.ResetSellClientOrderId()
		return nil
	}
	return fmt.Errorf("unknown Grid field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GridMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GridMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GridMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GridMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GridMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GridMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GridMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Grid unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GridMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Grid edge %s", name)
}

// MatchedTradeMutation represents an operation that mutates the MatchedTrade nodes in the graph.
type MatchedTradeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	strategyId            *string
	symbol                *string
	buyClientOrderId      *int64
	addbuyClientOrderId   *int64
	buyBaseAmount         *decimal.Decimal
	buyQuoteAmount        *decimal.Decimal
	buyOrderTimestamp     *int64
	addbuyOrderTimestamp  *int64
	sellClientOrderId     *int64
	addsellClientOrderId  *int64
	sellBaseAmount        *decimal.Decimal
	sellQuoteAmount       *decimal.Decimal
	sellOrderTimestamp    *int64
	addsellOrderTimestamp *int64
	profit                *float64
	addprofit             *float64
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*MatchedTrade, error)
	predicates            []predicate.MatchedTrade
}

var _ ent.Mutation = (*MatchedTradeMutation)(nil)

// matchedtradeOption allows management of the mutation configuration using functional options.
type matchedtradeOption func(*MatchedTradeMutation)

// newMatchedTradeMutation creates new mutation for the MatchedTrade entity.
func newMatchedTradeMutation(c config, op Op, opts ...matchedtradeOption) *MatchedTradeMutation {
	m := &MatchedTradeMutation{
		config:        c,
		op:            op,
		typ:           TypeMatchedTrade,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMatchedTradeID sets the ID field of the mutation.
func withMatchedTradeID(id int) matchedtradeOption {
	return func(m *MatchedTradeMutation) {
		var (
			err   error
			once  sync.Once
			value *MatchedTrade
		)
		m.oldValue = func(ctx context.Context) (*MatchedTrade, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MatchedTrade.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMatchedTrade sets the old MatchedTrade of the mutation.
func withMatchedTrade(node *MatchedTrade) matchedtradeOption {
	return func(m *MatchedTradeMutation) {
		m.oldValue = func(context.Context) (*MatchedTrade, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MatchedTradeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MatchedTradeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MatchedTradeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MatchedTradeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MatchedTrade.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStrategyId sets the "strategyId" field.
func (m *MatchedTradeMutation) SetStrategyId(s string) {
	m.strategyId = &s
}

// StrategyId returns the value of the "strategyId" field in the mutation.
func (m *MatchedTradeMutation) StrategyId() (r string, exists bool) {
	v := m.strategyId
	if v == nil {
		return
	}
	return *v, true
}

// OldStrategyId returns the old "strategyId" field's value of the MatchedTrade entity.
// If the MatchedTrade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchedTradeMutation) OldStrategyId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStrategyId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStrategyId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStrategyId: %w", err)
	}
	return oldValue.StrategyId, nil
}

// ResetStrategyId resets all changes to the "strategyId" field.
func (m *MatchedTradeMutation) ResetStrategyId() {
	m.strategyId = nil
}

// SetSymbol sets the "symbol" field.
func (m *MatchedTradeMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *MatchedTradeMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the MatchedTrade entity.
// If the MatchedTrade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchedTradeMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *MatchedTradeMutation) ResetSymbol() {
	m.symbol = nil
}

// SetBuyClientOrderId sets the "buyClientOrderId" field.
func (m *MatchedTradeMutation) SetBuyClientOrderId(i int64) {
	m.buyClientOrderId = &i
	m.addbuyClientOrderId = nil
}

// BuyClientOrderId returns the value of the "buyClientOrderId" field in the mutation.
func (m *MatchedTradeMutation) BuyClientOrderId() (r int64, exists bool) {
	v := m.buyClientOrderId
	if v == nil {
		return
	}
	return *v, true
}

// OldBuyClientOrderId returns the old "buyClientOrderId" field's value of the MatchedTrade entity.
// If the MatchedTrade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchedTradeMutation) OldBuyClientOrderId(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuyClientOrderId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuyClientOrderId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuyClientOrderId: %w", err)
	}
	return oldValue.BuyClientOrderId, nil
}

// AddBuyClientOrderId adds i to the "buyClientOrderId" field.
func (m *MatchedTradeMutation) AddBuyClientOrderId(i int64) {
	if m.addbuyClientOrderId != nil {
		*m.addbuyClientOrderId += i
	} else {
		m.addbuyClientOrderId = &i
	}
}

// AddedBuyClientOrderId returns the value that was added to the "buyClientOrderId" field in this mutation.
func (m *MatchedTradeMutation) AddedBuyClientOrderId() (r int64, exists bool) {
	v := m.addbuyClientOrderId
	if v == nil {
		return
	}
	return *v, true
}

// ClearBuyClientOrderId clears the value of the "buyClientOrderId" field.
func (m *MatchedTradeMutation) ClearBuyClientOrderId() {
	m.buyClientOrderId = nil
	m.addbuyClientOrderId = nil
	m.clearedFields[matchedtrade.FieldBuyClientOrderId] = struct{}{}
}

// BuyClientOrderIdCleared returns if the "buyClientOrderId" field was cleared in this mutation.
func (m *MatchedTradeMutation) BuyClientOrderIdCleared() bool {
	_, ok := m.clearedFields[matchedtrade.FieldBuyClientOrderId]
	return ok
}

// ResetBuyClientOrderId resets all changes to the "buyClientOrderId" field.
func (m *MatchedTradeMutation) ResetBuyClientOrderId() {
	m.buyClientOrderId = nil
	m.addbuyClientOrderId = nil
	delete(m.clearedFields, matchedtrade.FieldBuyClientOrderId)
}

// SetBuyBaseAmount sets the "buyBaseAmount" field.
func (m *MatchedTradeMutation) SetBuyBaseAmount(d decimal.Decimal) {
	m.buyBaseAmount = &d
}

// BuyBaseAmount returns the value of the "buyBaseAmount" field in the mutation.
func (m *MatchedTradeMutation) BuyBaseAmount() (r decimal.Decimal, exists bool) {
	v := m.buyBaseAmount
	if v == nil {
		return
	}
	return *v, true
}

// OldBuyBaseAmount returns the old "buyBaseAmount" field's value of the MatchedTrade entity.
// If the MatchedTrade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchedTradeMutation) OldBuyBaseAmount(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuyBaseAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuyBaseAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuyBaseAmount: %w", err)
	}
	return oldValue.BuyBaseAmount, nil
}

// ClearBuyBaseAmount clears the value of the "buyBaseAmount" field.
func (m *MatchedTradeMutation) ClearBuyBaseAmount() {
	m.buyBaseAmount = nil
	m.clearedFields[matchedtrade.FieldBuyBaseAmount] = struct{}{}
}

// BuyBaseAmountCleared returns if the "buyBaseAmount" field was cleared in this mutation.
func (m *MatchedTradeMutation) BuyBaseAmountCleared() bool {
	_, ok := m.clearedFields[matchedtrade.FieldBuyBaseAmount]
	return ok
}

// ResetBuyBaseAmount resets all changes to the "buyBaseAmount" field.
func (m *MatchedTradeMutation) ResetBuyBaseAmount() {
	m.buyBaseAmount = nil
	delete(m.clearedFields, matchedtrade.FieldBuyBaseAmount)
}

// SetBuyQuoteAmount sets the "buyQuoteAmount" field.
func (m *MatchedTradeMutation) SetBuyQuoteAmount(d decimal.Decimal) {
	m.buyQuoteAmount = &d
}

// BuyQuoteAmount returns the value of the "buyQuoteAmount" field in the mutation.
func (m *MatchedTradeMutation) BuyQuoteAmount() (r decimal.Decimal, exists bool) {
	v := m.buyQuoteAmount
	if v == nil {
		return
	}
	return *v, true
}

// OldBuyQuoteAmount returns the old "buyQuoteAmount" field's value of the MatchedTrade entity.
// If the MatchedTrade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchedTradeMutation) OldBuyQuoteAmount(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuyQuoteAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuyQuoteAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuyQuoteAmount: %w", err)
	}
	return oldValue.BuyQuoteAmount, nil
}

// ClearBuyQuoteAmount clears the value of the "buyQuoteAmount" field.
func (m *MatchedTradeMutation) ClearBuyQuoteAmount() {
	m.buyQuoteAmount = nil
	m.clearedFields[matchedtrade.FieldBuyQuoteAmount] = struct{}{}
}

// BuyQuoteAmountCleared returns if the "buyQuoteAmount" field was cleared in this mutation.
func (m *MatchedTradeMutation) BuyQuoteAmountCleared() bool {
	_, ok := m.clearedFields[matchedtrade.FieldBuyQuoteAmount]
	return ok
}

// ResetBuyQuoteAmount resets all changes to the "buyQuoteAmount" field.
func (m *MatchedTradeMutation) ResetBuyQuoteAmount() {
	m.buyQuoteAmount = nil
	delete(m.clearedFields, matchedtrade.FieldBuyQuoteAmount)
}

// SetBuyOrderTimestamp sets the "buyOrderTimestamp" field.
func (m *MatchedTradeMutation) SetBuyOrderTimestamp(i int64) {
	m.buyOrderTimestamp = &i
	m.addbuyOrderTimestamp = nil
}

// BuyOrderTimestamp returns the value of the "buyOrderTimestamp" field in the mutation.
func (m *MatchedTradeMutation) BuyOrderTimestamp() (r int64, exists bool) {
	v := m.buyOrderTimestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldBuyOrderTimestamp returns the old "buyOrderTimestamp" field's value of the MatchedTrade entity.
// If the MatchedTrade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchedTradeMutation) OldBuyOrderTimestamp(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuyOrderTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuyOrderTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuyOrderTimestamp: %w", err)
	}
	return oldValue.BuyOrderTimestamp, nil
}

// AddBuyOrderTimestamp adds i to the "buyOrderTimestamp" field.
func (m *MatchedTradeMutation) AddBuyOrderTimestamp(i int64) {
	if m.addbuyOrderTimestamp != nil {
		*m.addbuyOrderTimestamp += i
	} else {
		m.addbuyOrderTimestamp = &i
	}
}

// AddedBuyOrderTimestamp returns the value that was added to the "buyOrderTimestamp" field in this mutation.
func (m *MatchedTradeMutation) AddedBuyOrderTimestamp() (r int64, exists bool) {
	v := m.addbuyOrderTimestamp
	if v == nil {
		return
	}
	return *v, true
}

// ClearBuyOrderTimestamp clears the value of the "buyOrderTimestamp" field.
func (m *MatchedTradeMutation) ClearBuyOrderTimestamp() {
	m.buyOrderTimestamp = nil
	m.addbuyOrderTimestamp = nil
	m.clearedFields[matchedtrade.FieldBuyOrderTimestamp] = struct{}{}
}

// BuyOrderTimestampCleared returns if the "buyOrderTimestamp" field was cleared in this mutation.
func (m *MatchedTradeMutation) BuyOrderTimestampCleared() bool {
	_, ok := m.clearedFields[matchedtrade.FieldBuyOrderTimestamp]
	return ok
}

// ResetBuyOrderTimestamp resets all changes to the "buyOrderTimestamp" field.
func (m *MatchedTradeMutation) ResetBuyOrderTimestamp() {
	m.buyOrderTimestamp = nil
	m.addbuyOrderTimestamp = nil
	delete(m.clearedFields, matchedtrade.FieldBuyOrderTimestamp)
}

// SetSellClientOrderId sets the "sellClientOrderId" field.
func (m *MatchedTradeMutation) SetSellClientOrderId(i int64) {
	m.sellClientOrderId = &i
	m.addsellClientOrderId = nil
}

// SellClientOrderId returns the value of the "sellClientOrderId" field in the mutation.
func (m *MatchedTradeMutation) SellClientOrderId() (r int64, exists bool) {
	v := m.sellClientOrderId
	if v == nil {
		return
	}
	return *v, true
}

// OldSellClientOrderId returns the old "sellClientOrderId" field's value of the MatchedTrade entity.
// If the MatchedTrade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchedTradeMutation) OldSellClientOrderId(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSellClientOrderId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSellClientOrderId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSellClientOrderId: %w", err)
	}
	return oldValue.SellClientOrderId, nil
}

// AddSellClientOrderId adds i to the "sellClientOrderId" field.
func (m *MatchedTradeMutation) AddSellClientOrderId(i int64) {
	if m.addsellClientOrderId != nil {
		*m.addsellClientOrderId += i
	} else {
		m.addsellClientOrderId = &i
	}
}

// AddedSellClientOrderId returns the value that was added to the "sellClientOrderId" field in this mutation.
func (m *MatchedTradeMutation) AddedSellClientOrderId() (r int64, exists bool) {
	v := m.addsellClientOrderId
	if v == nil {
		return
	}
	return *v, true
}

// ClearSellClientOrderId clears the value of the "sellClientOrderId" field.
func (m *MatchedTradeMutation) ClearSellClientOrderId() {
	m.sellClientOrderId = nil
	m.addsellClientOrderId = nil
	m.clearedFields[matchedtrade.FieldSellClientOrderId] = struct{}{}
}

// SellClientOrderIdCleared returns if the "sellClientOrderId" field was cleared in this mutation.
func (m *MatchedTradeMutation) SellClientOrderIdCleared() bool {
	_, ok := m.clearedFields[matchedtrade.FieldSellClientOrderId]
	return ok
}

// ResetSellClientOrderId resets all changes to the "sellClientOrderId" field.
func (m *MatchedTradeMutation) ResetSellClientOrderId() {
	m.sellClientOrderId = nil
	m.addsellClientOrderId = nil
	delete(m.clearedFields, matchedtrade.FieldSellClientOrderId)
}

// SetSellBaseAmount sets the "sellBaseAmount" field.
func (m *MatchedTradeMutation) SetSellBaseAmount(d decimal.Decimal) {
	m.sellBaseAmount = &d
}

// SellBaseAmount returns the value of the "sellBaseAmount" field in the mutation.
func (m *MatchedTradeMutation) SellBaseAmount() (r decimal.Decimal, exists bool) {
	v := m.sellBaseAmount
	if v == nil {
		return
	}
	return *v, true
}

// OldSellBaseAmount returns the old "sellBaseAmount" field's value of the MatchedTrade entity.
// If the MatchedTrade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchedTradeMutation) OldSellBaseAmount(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSellBaseAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSellBaseAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSellBaseAmount: %w", err)
	}
	return oldValue.SellBaseAmount, nil
}

// ClearSellBaseAmount clears the value of the "sellBaseAmount" field.
func (m *MatchedTradeMutation) ClearSellBaseAmount() {
	m.sellBaseAmount = nil
	m.clearedFields[matchedtrade.FieldSellBaseAmount] = struct{}{}
}

// SellBaseAmountCleared returns if the "sellBaseAmount" field was cleared in this mutation.
func (m *MatchedTradeMutation) SellBaseAmountCleared() bool {
	_, ok := m.clearedFields[matchedtrade.FieldSellBaseAmount]
	return ok
}

// ResetSellBaseAmount resets all changes to the "sellBaseAmount" field.
func (m *MatchedTradeMutation) ResetSellBaseAmount() {
	m.sellBaseAmount = nil
	delete(m.clearedFields, matchedtrade.FieldSellBaseAmount)
}

// SetSellQuoteAmount sets the "sellQuoteAmount" field.
func (m *MatchedTradeMutation) SetSellQuoteAmount(d decimal.Decimal) {
	m.sellQuoteAmount = &d
}

// SellQuoteAmount returns the value of the "sellQuoteAmount" field in the mutation.
func (m *MatchedTradeMutation) SellQuoteAmount() (r decimal.Decimal, exists bool) {
	v := m.sellQuoteAmount
	if v == nil {
		return
	}
	return *v, true
}

// OldSellQuoteAmount returns the old "sellQuoteAmount" field's value of the MatchedTrade entity.
// If the MatchedTrade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchedTradeMutation) OldSellQuoteAmount(ctx context.Context) (v *decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSellQuoteAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSellQuoteAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSellQuoteAmount: %w", err)
	}
	return oldValue.SellQuoteAmount, nil
}

// ClearSellQuoteAmount clears the value of the "sellQuoteAmount" field.
func (m *MatchedTradeMutation) ClearSellQuoteAmount() {
	m.sellQuoteAmount = nil
	m.clearedFields[matchedtrade.FieldSellQuoteAmount] = struct{}{}
}

// SellQuoteAmountCleared returns if the "sellQuoteAmount" field was cleared in this mutation.
func (m *MatchedTradeMutation) SellQuoteAmountCleared() bool {
	_, ok := m.clearedFields[matchedtrade.FieldSellQuoteAmount]
	return ok
}

// ResetSellQuoteAmount resets all changes to the "sellQuoteAmount" field.
func (m *MatchedTradeMutation) ResetSellQuoteAmount() {
	m.sellQuoteAmount = nil
	delete(m.clearedFields, matchedtrade.FieldSellQuoteAmount)
}

// SetSellOrderTimestamp sets the "sellOrderTimestamp" field.
func (m *MatchedTradeMutation) SetSellOrderTimestamp(i int64) {
	m.sellOrderTimestamp = &i
	m.addsellOrderTimestamp = nil
}

// SellOrderTimestamp returns the value of the "sellOrderTimestamp" field in the mutation.
func (m *MatchedTradeMutation) SellOrderTimestamp() (r int64, exists bool) {
	v := m.sellOrderTimestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldSellOrderTimestamp returns the old "sellOrderTimestamp" field's value of the MatchedTrade entity.
// If the MatchedTrade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchedTradeMutation) OldSellOrderTimestamp(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSellOrderTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSellOrderTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSellOrderTimestamp: %w", err)
	}
	return oldValue.SellOrderTimestamp, nil
}

// AddSellOrderTimestamp adds i to the "sellOrderTimestamp" field.
func (m *MatchedTradeMutation) AddSellOrderTimestamp(i int64) {
	if m.addsellOrderTimestamp != nil {
		*m.addsellOrderTimestamp += i
	} else {
		m.addsellOrderTimestamp = &i
	}
}

// AddedSellOrderTimestamp returns the value that was added to the "sellOrderTimestamp" field in this mutation.
func (m *MatchedTradeMutation) AddedSellOrderTimestamp() (r int64, exists bool) {
	v := m.addsellOrderTimestamp
	if v == nil {
		return
	}
	return *v, true
}

// ClearSellOrderTimestamp clears the value of the "sellOrderTimestamp" field.
func (m *MatchedTradeMutation) ClearSellOrderTimestamp() {
	m.sellOrderTimestamp = nil
	m.addsellOrderTimestamp = nil
	m.clearedFields[matchedtrade.FieldSellOrderTimestamp] = struct{}{}
}

// SellOrderTimestampCleared returns if the "sellOrderTimestamp" field was cleared in this mutation.
func (m *MatchedTradeMutation) SellOrderTimestampCleared() bool {
	_, ok := m.clearedFields[matchedtrade.FieldSellOrderTimestamp]
	return ok
}

// ResetSellOrderTimestamp resets all changes to the "sellOrderTimestamp" field.
func (m *MatchedTradeMutation) ResetSellOrderTimestamp() {
	m.sellOrderTimestamp = nil
	m.addsellOrderTimestamp = nil
	delete(m.clearedFields, matchedtrade.FieldSellOrderTimestamp)
}

// SetProfit sets the "profit" field.
func (m *MatchedTradeMutation) SetProfit(f float64) {
	m.profit = &f
	m.addprofit = nil
}

// Profit returns the value of the "profit" field in the mutation.
func (m *MatchedTradeMutation) Profit() (r float64, exists bool) {
	v := m.profit
	if v == nil {
		return
	}
	return *v, true
}

// OldProfit returns the old "profit" field's value of the MatchedTrade entity.
// If the MatchedTrade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchedTradeMutation) OldProfit(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfit: %w", err)
	}
	return oldValue.Profit, nil
}

// AddProfit adds f to the "profit" field.
func (m *MatchedTradeMutation) AddProfit(f float64) {
	if m.addprofit != nil {
		*m.addprofit += f
	} else {
		m.addprofit = &f
	}
}

// AddedProfit returns the value that was added to the "profit" field in this mutation.
func (m *MatchedTradeMutation) AddedProfit() (r float64, exists bool) {
	v := m.addprofit
	if v == nil {
		return
	}
	return *v, true
}

// ClearProfit clears the value of the "profit" field.
func (m *MatchedTradeMutation) ClearProfit() {
	m.profit = nil
	m.addprofit = nil
	m.clearedFields[matchedtrade.FieldProfit] = struct{}{}
}

// ProfitCleared returns if the "profit" field was cleared in this mutation.
func (m *MatchedTradeMutation) ProfitCleared() bool {
	_, ok := m.clearedFields[matchedtrade.FieldProfit]
	return ok
}

// ResetProfit resets all changes to the "profit" field.
func (m *MatchedTradeMutation) ResetProfit() {
	m.profit = nil
	m.addprofit = nil
	delete(m.clearedFields, matchedtrade.FieldProfit)
}

// Where appends a list predicates to the MatchedTradeMutation builder.
func (m *MatchedTradeMutation) Where(ps ...predicate.MatchedTrade) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MatchedTradeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MatchedTradeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MatchedTrade, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MatchedTradeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MatchedTradeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MatchedTrade).
func (m *MatchedTradeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MatchedTradeMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.strategyId != nil {
		fields = append(fields, matchedtrade.FieldStrategyId)
	}
	if m.symbol != nil {
		fields = append(fields, matchedtrade.FieldSymbol)
	}
	if m.buyClientOrderId != nil {
		fields = append(fields, matchedtrade.FieldBuyClientOrderId)
	}
	if m.buyBaseAmount != nil {
		fields = append(fields, matchedtrade.FieldBuyBaseAmount)
	}
	if m.buyQuoteAmount != nil {
		fields = append(fields, matchedtrade.FieldBuyQuoteAmount)
	}
	if m.buyOrderTimestamp != nil {
		fields = append(fields, matchedtrade.FieldBuyOrderTimestamp)
	}
	if m.sellClientOrderId != nil {
		fields = append(fields, matchedtrade.FieldSellClientOrderId)
	}
	if m.sellBaseAmount != nil {
		fields = append(fields, matchedtrade.FieldSellBaseAmount)
	}
	if m.sellQuoteAmount != nil {
		fields = append(fields, matchedtrade.FieldSellQuoteAmount)
	}
	if m.sellOrderTimestamp != nil {
		fields = append(fields, matchedtrade.FieldSellOrderTimestamp)
	}
	if m.profit != nil {
		fields = append(fields, matchedtrade.FieldProfit)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MatchedTradeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case matchedtrade.FieldStrategyId:
		return m.StrategyId()
	case matchedtrade.FieldSymbol:
		return m.Symbol()
	case matchedtrade.FieldBuyClientOrderId:
		return m.BuyClientOrderId()
	case matchedtrade.FieldBuyBaseAmount:
		return m.BuyBaseAmount()
	case matchedtrade.FieldBuyQuoteAmount:
		return m.BuyQuoteAmount()
	case matchedtrade.FieldBuyOrderTimestamp:
		return m.BuyOrderTimestamp()
	case matchedtrade.FieldSellClientOrderId:
		return m.SellClientOrderId()
	case matchedtrade.FieldSellBaseAmount:
		return m.SellBaseAmount()
	case matchedtrade.FieldSellQuoteAmount:
		return m.SellQuoteAmount()
	case matchedtrade.FieldSellOrderTimestamp:
		return m.SellOrderTimestamp()
	case matchedtrade.FieldProfit:
		return m.Profit()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MatchedTradeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case matchedtrade.FieldStrategyId:
		return m.OldStrategyId(ctx)
	case matchedtrade.FieldSymbol:
		return m.OldSymbol(ctx)
	case matchedtrade.FieldBuyClientOrderId:
		return m.OldBuyClientOrderId(ctx)
	case matchedtrade.FieldBuyBaseAmount:
		return m.OldBuyBaseAmount(ctx)
	case matchedtrade.FieldBuyQuoteAmount:
		return m.OldBuyQuoteAmount(ctx)
	case matchedtrade.FieldBuyOrderTimestamp:
		return m.OldBuyOrderTimestamp(ctx)
	case matchedtrade.FieldSellClientOrderId:
		return m.OldSellClientOrderId(ctx)
	case matchedtrade.FieldSellBaseAmount:
		return m.OldSellBaseAmount(ctx)
	case matchedtrade.FieldSellQuoteAmount:
		return m.OldSellQuoteAmount(ctx)
	case matchedtrade.FieldSellOrderTimestamp:
		return m.OldSellOrderTimestamp(ctx)
	case matchedtrade.FieldProfit:
		return m.OldProfit(ctx)
	}
	return nil, fmt.Errorf("unknown MatchedTrade field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MatchedTradeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case matchedtrade.FieldStrategyId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStrategyId(v)
		return nil
	case matchedtrade.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case matchedtrade.FieldBuyClientOrderId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuyClientOrderId(v)
		return nil
	case matchedtrade.FieldBuyBaseAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuyBaseAmount(v)
		return nil
	case matchedtrade.FieldBuyQuoteAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuyQuoteAmount(v)
		return nil
	case matchedtrade.FieldBuyOrderTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuyOrderTimestamp(v)
		return nil
	case matchedtrade.FieldSellClientOrderId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSellClientOrderId(v)
		return nil
	case matchedtrade.FieldSellBaseAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSellBaseAmount(v)
		return nil
	case matchedtrade.FieldSellQuoteAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSellQuoteAmount(v)
		return nil
	case matchedtrade.FieldSellOrderTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSellOrderTimestamp(v)
		return nil
	case matchedtrade.FieldProfit:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfit(v)
		return nil
	}
	return fmt.Errorf("unknown MatchedTrade field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MatchedTradeMutation) AddedFields() []string {
	var fields []string
	if m.addbuyClientOrderId != nil {
		fields = append(fields, matchedtrade.FieldBuyClientOrderId)
	}
	if m.addbuyOrderTimestamp != nil {
		fields = append(fields, matchedtrade.FieldBuyOrderTimestamp)
	}
	if m.addsellClientOrderId != nil {
		fields = append(fields, matchedtrade.FieldSellClientOrderId)
	}
	if m.addsellOrderTimestamp != nil {
		fields = append(fields, matchedtrade.FieldSellOrderTimestamp)
	}
	if m.addprofit != nil {
		fields = append(fields, matchedtrade.FieldProfit)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MatchedTradeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case matchedtrade.FieldBuyClientOrderId:
		return m.AddedBuyClientOrderId()
	case matchedtrade.FieldBuyOrderTimestamp:
		return m.AddedBuyOrderTimestamp()
	case matchedtrade.FieldSellClientOrderId:
		return m.AddedSellClientOrderId()
	case matchedtrade.FieldSellOrderTimestamp:
		return m.AddedSellOrderTimestamp()
	case matchedtrade.FieldProfit:
		return m.AddedProfit()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MatchedTradeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case matchedtrade.FieldBuyClientOrderId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBuyClientOrderId(v)
		return nil
	case matchedtrade.FieldBuyOrderTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBuyOrderTimestamp(v)
		return nil
	case matchedtrade.FieldSellClientOrderId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSellClientOrderId(v)
		return nil
	case matchedtrade.FieldSellOrderTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSellOrderTimestamp(v)
		return nil
	case matchedtrade.FieldProfit:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProfit(v)
		return nil
	}
	return fmt.Errorf("unknown MatchedTrade numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MatchedTradeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(matchedtrade.FieldBuyClientOrderId) {
		fields = append(fields, matchedtrade.FieldBuyClientOrderId)
	}
	if m.FieldCleared(matchedtrade.FieldBuyBaseAmount) {
		fields = append(fields, matchedtrade.FieldBuyBaseAmount)
	}
	if m.FieldCleared(matchedtrade.FieldBuyQuoteAmount) {
		fields = append(fields, matchedtrade.FieldBuyQuoteAmount)
	}
	if m.FieldCleared(matchedtrade.FieldBuyOrderTimestamp) {
		fields = append(fields, matchedtrade.FieldBuyOrderTimestamp)
	}
	if m.FieldCleared(matchedtrade.FieldSellClientOrderId) {
		fields = append(fields, matchedtrade.FieldSellClientOrderId)
	}
	if m.FieldCleared(matchedtrade.FieldSellBaseAmount) {
		fields = append(fields, matchedtrade.FieldSellBaseAmount)
	}
	if m.FieldCleared(matchedtrade.FieldSellQuoteAmount) {
		fields = append(fields, matchedtrade.FieldSellQuoteAmount)
	}
	if m.FieldCleared(matchedtrade.FieldSellOrderTimestamp) {
		fields = append(fields, matchedtrade.FieldSellOrderTimestamp)
	}
	if m.FieldCleared(matchedtrade.FieldProfit) {
		fields = append(fields, matchedtrade.FieldProfit)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MatchedTradeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MatchedTradeMutation) ClearField(name string) error {
	switch name {
	case matchedtrade.FieldBuyClientOrderId:
		m.ClearBuyClientOrderId()
		return nil
	case matchedtrade.FieldBuyBaseAmount:
		m.ClearBuyBaseAmount()
		return nil
	case matchedtrade.FieldBuyQuoteAmount:
		m.ClearBuyQuoteAmount()
		return nil
	case matchedtrade.FieldBuyOrderTimestamp:
		m.ClearBuyOrderTimestamp()
		return nil
	case matchedtrade.FieldSellClientOrderId:
		m.ClearSellClientOrderId()
		return nil
	case matchedtrade.FieldSellBaseAmount:
		m.ClearSellBaseAmount()
		return nil
	case matchedtrade.FieldSellQuoteAmount:
		m.ClearSellQuoteAmount()
		return nil
	case matchedtrade.FieldSellOrderTimestamp:
		m.ClearSellOrderTimestamp()
		return nil
	case matchedtrade.FieldProfit:
		m.ClearProfit()
		return nil
	}
	return fmt.Errorf("unknown MatchedTrade nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MatchedTradeMutation) ResetField(name string) error {
	switch name {
	case matchedtrade.FieldStrategyId:
		m.ResetStrategyId()
		return nil
	case matchedtrade.FieldSymbol:
		m.ResetSymbol()
		return nil
	case matchedtrade.FieldBuyClientOrderId:
		m.ResetBuyClientOrderId()
		return nil
	case matchedtrade.FieldBuyBaseAmount:
		m.ResetBuyBaseAmount()
		return nil
	case matchedtrade.FieldBuyQuoteAmount:
		m.ResetBuyQuoteAmount()
		return nil
	case matchedtrade.FieldBuyOrderTimestamp:
		m.ResetBuyOrderTimestamp()
		return nil
	case matchedtrade.FieldSellClientOrderId:
		m.ResetSellClientOrderId()
		return nil
	case matchedtrade.FieldSellBaseAmount:
		m.ResetSellBaseAmount()
		return nil
	case matchedtrade.FieldSellQuoteAmount:
		m.ResetSellQuoteAmount()
		return nil
	case matchedtrade.FieldSellOrderTimestamp:
		m.ResetSellOrderTimestamp()
		return nil
	case matchedtrade.FieldProfit:
		m.ResetProfit()
		return nil
	}
	return fmt.Errorf("unknown MatchedTrade field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MatchedTradeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MatchedTradeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MatchedTradeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MatchedTradeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MatchedTradeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MatchedTradeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MatchedTradeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MatchedTrade unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MatchedTradeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MatchedTrade edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op                Op
	typ               string
	id                *int
	create_time       *time.Time
	update_time       *time.Time
	exchange          *string
	account           *string
	symbol            *string
	orderId           *int64
	addorderId        *int64
	clientOrderId     *int64
	addclientOrderId  *int64
	side              *order.Side
	price             *decimal.Decimal
	baseAmount        *decimal.Decimal
	filledBaseAmount  *decimal.Decimal
	filledQuoteAmount *decimal.Decimal
	status            *order.Status
	timestamp         *int64
	addtimestamp      *int64
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Order, error)
	predicates        []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id int) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *OrderMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrderMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrderMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrderMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrderMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrderMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetExchange sets the "exchange" field.
func (m *OrderMutation) SetExchange(s string) {
	m.exchange = &s
}

// Exchange returns the value of the "exchange" field in the mutation.
func (m *OrderMutation) Exchange() (r string, exists bool) {
	v := m.exchange
	if v == nil {
		return
	}
	return *v, true
}

// OldExchange returns the old "exchange" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldExchange(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExchange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExchange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExchange: %w", err)
	}
	return oldValue.Exchange, nil
}

// ResetExchange resets all changes to the "exchange" field.
func (m *OrderMutation) ResetExchange() {
	m.exchange = nil
}

// SetAccount sets the "account" field.
func (m *OrderMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the value of the "account" field in the mutation.
func (m *OrderMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old "account" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount resets all changes to the "account" field.
func (m *OrderMutation) ResetAccount() {
	m.account = nil
}

// SetSymbol sets the "symbol" field.
func (m *OrderMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *OrderMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *OrderMutation) ResetSymbol() {
	m.symbol = nil
}

// SetOrderId sets the "orderId" field.
func (m *OrderMutation) SetOrderId(i int64) {
	m.orderId = &i
	m.addorderId = nil
}

// OrderId returns the value of the "orderId" field in the mutation.
func (m *OrderMutation) OrderId() (r int64, exists bool) {
	v := m.orderId
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderId returns the old "orderId" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOrderId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderId: %w", err)
	}
	return oldValue.OrderId, nil
}

// AddOrderId adds i to the "orderId" field.
func (m *OrderMutation) AddOrderId(i int64) {
	if m.addorderId != nil {
		*m.addorderId += i
	} else {
		m.addorderId = &i
	}
}

// AddedOrderId returns the value that was added to the "orderId" field in this mutation.
func (m *OrderMutation) AddedOrderId() (r int64, exists bool) {
	v := m.addorderId
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderId resets all changes to the "orderId" field.
func (m *OrderMutation) ResetOrderId() {
	m.orderId = nil
	m.addorderId = nil
}

// SetClientOrderId sets the "clientOrderId" field.
func (m *OrderMutation) SetClientOrderId(i int64) {
	m.clientOrderId = &i
	m.addclientOrderId = nil
}

// ClientOrderId returns the value of the "clientOrderId" field in the mutation.
func (m *OrderMutation) ClientOrderId() (r int64, exists bool) {
	v := m.clientOrderId
	if v == nil {
		return
	}
	return *v, true
}

// OldClientOrderId returns the old "clientOrderId" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldClientOrderId(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientOrderId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientOrderId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientOrderId: %w", err)
	}
	return oldValue.ClientOrderId, nil
}

// AddClientOrderId adds i to the "clientOrderId" field.
func (m *OrderMutation) AddClientOrderId(i int64) {
	if m.addclientOrderId != nil {
		*m.addclientOrderId += i
	} else {
		m.addclientOrderId = &i
	}
}

// AddedClientOrderId returns the value that was added to the "clientOrderId" field in this mutation.
func (m *OrderMutation) AddedClientOrderId() (r int64, exists bool) {
	v := m.addclientOrderId
	if v == nil {
		return
	}
	return *v, true
}

// ResetClientOrderId resets all changes to the "clientOrderId" field.
func (m *OrderMutation) ResetClientOrderId() {
	m.clientOrderId = nil
	m.addclientOrderId = nil
}

// SetSide sets the "side" field.
func (m *OrderMutation) SetSide(o order.Side) {
	m.side = &o
}

// Side returns the value of the "side" field in the mutation.
func (m *OrderMutation) Side() (r order.Side, exists bool) {
	v := m.side
	if v == nil {
		return
	}
	return *v, true
}

// OldSide returns the old "side" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldSide(ctx context.Context) (v order.Side, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSide is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSide requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSide: %w", err)
	}
	return oldValue.Side, nil
}

// ResetSide resets all changes to the "side" field.
func (m *OrderMutation) ResetSide() {
	m.side = nil
}

// SetPrice sets the "price" field.
func (m *OrderMutation) SetPrice(d decimal.Decimal) {
	m.price = &d
}

// Price returns the value of the "price" field in the mutation.
func (m *OrderMutation) Price() (r decimal.Decimal, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPrice(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ResetPrice resets all changes to the "price" field.
func (m *OrderMutation) ResetPrice() {
	m.price = nil
}

// SetBaseAmount sets the "baseAmount" field.
func (m *OrderMutation) SetBaseAmount(d decimal.Decimal) {
	m.baseAmount = &d
}

// BaseAmount returns the value of the "baseAmount" field in the mutation.
func (m *OrderMutation) BaseAmount() (r decimal.Decimal, exists bool) {
	v := m.baseAmount
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseAmount returns the old "baseAmount" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldBaseAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseAmount: %w", err)
	}
	return oldValue.BaseAmount, nil
}

// ResetBaseAmount resets all changes to the "baseAmount" field.
func (m *OrderMutation) ResetBaseAmount() {
	m.baseAmount = nil
}

// SetFilledBaseAmount sets the "filledBaseAmount" field.
func (m *OrderMutation) SetFilledBaseAmount(d decimal.Decimal) {
	m.filledBaseAmount = &d
}

// FilledBaseAmount returns the value of the "filledBaseAmount" field in the mutation.
func (m *OrderMutation) FilledBaseAmount() (r decimal.Decimal, exists bool) {
	v := m.filledBaseAmount
	if v == nil {
		return
	}
	return *v, true
}

// OldFilledBaseAmount returns the old "filledBaseAmount" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldFilledBaseAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilledBaseAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilledBaseAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilledBaseAmount: %w", err)
	}
	return oldValue.FilledBaseAmount, nil
}

// ResetFilledBaseAmount resets all changes to the "filledBaseAmount" field.
func (m *OrderMutation) ResetFilledBaseAmount() {
	m.filledBaseAmount = nil
}

// SetFilledQuoteAmount sets the "filledQuoteAmount" field.
func (m *OrderMutation) SetFilledQuoteAmount(d decimal.Decimal) {
	m.filledQuoteAmount = &d
}

// FilledQuoteAmount returns the value of the "filledQuoteAmount" field in the mutation.
func (m *OrderMutation) FilledQuoteAmount() (r decimal.Decimal, exists bool) {
	v := m.filledQuoteAmount
	if v == nil {
		return
	}
	return *v, true
}

// OldFilledQuoteAmount returns the old "filledQuoteAmount" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldFilledQuoteAmount(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilledQuoteAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilledQuoteAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilledQuoteAmount: %w", err)
	}
	return oldValue.FilledQuoteAmount, nil
}

// ResetFilledQuoteAmount resets all changes to the "filledQuoteAmount" field.
func (m *OrderMutation) ResetFilledQuoteAmount() {
	m.filledQuoteAmount = nil
}

// SetStatus sets the "status" field.
func (m *OrderMutation) SetStatus(o order.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderMutation) Status() (r order.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatus(ctx context.Context) (v order.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderMutation) ResetStatus() {
	m.status = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *OrderMutation) SetTimestamp(i int64) {
	m.timestamp = &i
	m.addtimestamp = nil
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *OrderMutation) Timestamp() (r int64, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTimestamp(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// AddTimestamp adds i to the "timestamp" field.
func (m *OrderMutation) AddTimestamp(i int64) {
	if m.addtimestamp != nil {
		*m.addtimestamp += i
	} else {
		m.addtimestamp = &i
	}
}

// AddedTimestamp returns the value that was added to the "timestamp" field in this mutation.
func (m *OrderMutation) AddedTimestamp() (r int64, exists bool) {
	v := m.addtimestamp
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *OrderMutation) ResetTimestamp() {
	m.timestamp = nil
	m.addtimestamp = nil
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Order, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.create_time != nil {
		fields = append(fields, order.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, order.FieldUpdateTime)
	}
	if m.exchange != nil {
		fields = append(fields, order.FieldExchange)
	}
	if m.account != nil {
		fields = append(fields, order.FieldAccount)
	}
	if m.symbol != nil {
		fields = append(fields, order.FieldSymbol)
	}
	if m.orderId != nil {
		fields = append(fields, order.FieldOrderId)
	}
	if m.clientOrderId != nil {
		fields = append(fields, order.FieldClientOrderId)
	}
	if m.side != nil {
		fields = append(fields, order.FieldSide)
	}
	if m.price != nil {
		fields = append(fields, order.FieldPrice)
	}
	if m.baseAmount != nil {
		fields = append(fields, order.FieldBaseAmount)
	}
	if m.filledBaseAmount != nil {
		fields = append(fields, order.FieldFilledBaseAmount)
	}
	if m.filledQuoteAmount != nil {
		fields = append(fields, order.FieldFilledQuoteAmount)
	}
	if m.status != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.timestamp != nil {
		fields = append(fields, order.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldCreateTime:
		return m.CreateTime()
	case order.FieldUpdateTime:
		return m.UpdateTime()
	case order.FieldExchange:
		return m.Exchange()
	case order.FieldAccount:
		return m.Account()
	case order.FieldSymbol:
		return m.Symbol()
	case order.FieldOrderId:
		return m.OrderId()
	case order.FieldClientOrderId:
		return m.ClientOrderId()
	case order.FieldSide:
		return m.Side()
	case order.FieldPrice:
		return m.Price()
	case order.FieldBaseAmount:
		return m.BaseAmount()
	case order.FieldFilledBaseAmount:
		return m.FilledBaseAmount()
	case order.FieldFilledQuoteAmount:
		return m.FilledQuoteAmount()
	case order.FieldStatus:
		return m.Status()
	case order.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case order.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case order.FieldExchange:
		return m.OldExchange(ctx)
	case order.FieldAccount:
		return m.OldAccount(ctx)
	case order.FieldSymbol:
		return m.OldSymbol(ctx)
	case order.FieldOrderId:
		return m.OldOrderId(ctx)
	case order.FieldClientOrderId:
		return m.OldClientOrderId(ctx)
	case order.FieldSide:
		return m.OldSide(ctx)
	case order.FieldPrice:
		return m.OldPrice(ctx)
	case order.FieldBaseAmount:
		return m.OldBaseAmount(ctx)
	case order.FieldFilledBaseAmount:
		return m.OldFilledBaseAmount(ctx)
	case order.FieldFilledQuoteAmount:
		return m.OldFilledQuoteAmount(ctx)
	case order.FieldStatus:
		return m.OldStatus(ctx)
	case order.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case order.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case order.FieldExchange:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExchange(v)
		return nil
	case order.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case order.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case order.FieldOrderId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderId(v)
		return nil
	case order.FieldClientOrderId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientOrderId(v)
		return nil
	case order.FieldSide:
		v, ok := value.(order.Side)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSide(v)
		return nil
	case order.FieldPrice:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case order.FieldBaseAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseAmount(v)
		return nil
	case order.FieldFilledBaseAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilledBaseAmount(v)
		return nil
	case order.FieldFilledQuoteAmount:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilledQuoteAmount(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(order.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case order.FieldTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.addorderId != nil {
		fields = append(fields, order.FieldOrderId)
	}
	if m.addclientOrderId != nil {
		fields = append(fields, order.FieldClientOrderId)
	}
	if m.addtimestamp != nil {
		fields = append(fields, order.FieldTimestamp)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldOrderId:
		return m.AddedOrderId()
	case order.FieldClientOrderId:
		return m.AddedClientOrderId()
	case order.FieldTimestamp:
		return m.AddedTimestamp()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldOrderId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderId(v)
		return nil
	case order.FieldClientOrderId:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientOrderId(v)
		return nil
	case order.FieldTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case order.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case order.FieldExchange:
		m.ResetExchange()
		return nil
	case order.FieldAccount:
		m.ResetAccount()
		return nil
	case order.FieldSymbol:
		m.ResetSymbol()
		return nil
	case order.FieldOrderId:
		m.ResetOrderId()
		return nil
	case order.FieldClientOrderId:
		m.ResetClientOrderId()
		return nil
	case order.FieldSide:
		m.ResetSide()
		return nil
	case order.FieldPrice:
		m.ResetPrice()
		return nil
	case order.FieldBaseAmount:
		m.ResetBaseAmount()
		return nil
	case order.FieldFilledBaseAmount:
		m.ResetFilledBaseAmount()
		return nil
	case order.FieldFilledQuoteAmount:
		m.ResetFilledQuoteAmount()
		return nil
	case order.FieldStatus:
		m.ResetStatus()
		return nil
	case order.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Order edge %s", name)
}

// StrategyMutation represents an operation that mutates the Strategy nodes in the graph.
type StrategyMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	create_time                 *time.Time
	update_time                 *time.Time
	guid                        *string
	owner                       *int64
	addowner                    *int64
	exchange                    *string
	symbol                      *string
	account                     *string
	mode                        *strategy.Mode
	marginMode                  *strategy.MarginMode
	quantityMode                *strategy.QuantityMode
	priceUpper                  *decimal.Decimal
	priceLower                  *decimal.Decimal
	gridNum                     *int
	addgridNum                  *int
	leverage                    *int
	addleverage                 *int
	initialOrderSize            *decimal.Decimal
	stopLossRatio               *decimal.Decimal
	takeProfitRatio             *decimal.Decimal
	enableAutoExit              *bool
	enablePushNotification      *bool
	lastLowerThresholdAlertTime *time.Time
	lastUpperThresholdAlertTime *time.Time
	status                      *strategy.Status
	exchangeApiKey              *string
	exchangeSecretKey           *string
	exchangePassphrase          *string
	clearedFields               map[string]struct{}
	done                        bool
	oldValue                    func(context.Context) (*Strategy, error)
	predicates                  []predicate.Strategy
}

var _ ent.Mutation = (*StrategyMutation)(nil)

// strategyOption allows management of the mutation configuration using functional options.
type strategyOption func(*StrategyMutation)

// newStrategyMutation creates new mutation for the Strategy entity.
func newStrategyMutation(c config, op Op, opts ...strategyOption) *StrategyMutation {
	m := &StrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStrategyID sets the ID field of the mutation.
func withStrategyID(id int) strategyOption {
	return func(m *StrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *Strategy
		)
		m.oldValue = func(ctx context.Context) (*Strategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Strategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStrategy sets the old Strategy of the mutation.
func withStrategy(node *Strategy) strategyOption {
	return func(m *StrategyMutation) {
		m.oldValue = func(context.Context) (*Strategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StrategyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StrategyMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Strategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *StrategyMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *StrategyMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *StrategyMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *StrategyMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *StrategyMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *StrategyMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetGUID sets the "guid" field.
func (m *StrategyMutation) SetGUID(s string) {
	m.guid = &s
}

// GUID returns the value of the "guid" field in the mutation.
func (m *StrategyMutation) GUID() (r string, exists bool) {
	v := m.guid
	if v == nil {
		return
	}
	return *v, true
}

// OldGUID returns the old "guid" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldGUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGUID: %w", err)
	}
	return oldValue.GUID, nil
}

// ResetGUID resets all changes to the "guid" field.
func (m *StrategyMutation) ResetGUID() {
	m.guid = nil
}

// SetOwner sets the "owner" field.
func (m *StrategyMutation) SetOwner(i int64) {
	m.owner = &i
	m.addowner = nil
}

// Owner returns the value of the "owner" field in the mutation.
func (m *StrategyMutation) Owner() (r int64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldOwner(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// AddOwner adds i to the "owner" field.
func (m *StrategyMutation) AddOwner(i int64) {
	if m.addowner != nil {
		*m.addowner += i
	} else {
		m.addowner = &i
	}
}

// AddedOwner returns the value that was added to the "owner" field in this mutation.
func (m *StrategyMutation) AddedOwner() (r int64, exists bool) {
	v := m.addowner
	if v == nil {
		return
	}
	return *v, true
}

// ResetOwner resets all changes to the "owner" field.
func (m *StrategyMutation) ResetOwner() {
	m.owner = nil
	m.addowner = nil
}

// SetExchange sets the "exchange" field.
func (m *StrategyMutation) SetExchange(s string) {
	m.exchange = &s
}

// Exchange returns the value of the "exchange" field in the mutation.
func (m *StrategyMutation) Exchange() (r string, exists bool) {
	v := m.exchange
	if v == nil {
		return
	}
	return *v, true
}

// OldExchange returns the old "exchange" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldExchange(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExchange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExchange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExchange: %w", err)
	}
	return oldValue.Exchange, nil
}

// ResetExchange resets all changes to the "exchange" field.
func (m *StrategyMutation) ResetExchange() {
	m.exchange = nil
}

// SetSymbol sets the "symbol" field.
func (m *StrategyMutation) SetSymbol(s string) {
	m.symbol = &s
}

// Symbol returns the value of the "symbol" field in the mutation.
func (m *StrategyMutation) Symbol() (r string, exists bool) {
	v := m.symbol
	if v == nil {
		return
	}
	return *v, true
}

// OldSymbol returns the old "symbol" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldSymbol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSymbol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSymbol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymbol: %w", err)
	}
	return oldValue.Symbol, nil
}

// ResetSymbol resets all changes to the "symbol" field.
func (m *StrategyMutation) ResetSymbol() {
	m.symbol = nil
}

// SetAccount sets the "account" field.
func (m *StrategyMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the value of the "account" field in the mutation.
func (m *StrategyMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old "account" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount resets all changes to the "account" field.
func (m *StrategyMutation) ResetAccount() {
	m.account = nil
}

// SetMode sets the "mode" field.
func (m *StrategyMutation) SetMode(s strategy.Mode) {
	m.mode = &s
}

// Mode returns the value of the "mode" field in the mutation.
func (m *StrategyMutation) Mode() (r strategy.Mode, exists bool) {
	v := m.mode
	if v == nil {
		return
	}
	return *v, true
}

// OldMode returns the old "mode" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldMode(ctx context.Context) (v strategy.Mode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMode: %w", err)
	}
	return oldValue.Mode, nil
}

// ResetMode resets all changes to the "mode" field.
func (m *StrategyMutation) ResetMode() {
	m.mode = nil
}

// SetMarginMode sets the "marginMode" field.
func (m *StrategyMutation) SetMarginMode(sm strategy.MarginMode) {
	m.marginMode = &sm
}

// MarginMode returns the value of the "marginMode" field in the mutation.
func (m *StrategyMutation) MarginMode() (r strategy.MarginMode, exists bool) {
	v := m.marginMode
	if v == nil {
		return
	}
	return *v, true
}

// OldMarginMode returns the old "marginMode" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldMarginMode(ctx context.Context) (v strategy.MarginMode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMarginMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMarginMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMarginMode: %w", err)
	}
	return oldValue.MarginMode, nil
}

// ResetMarginMode resets all changes to the "marginMode" field.
func (m *StrategyMutation) ResetMarginMode() {
	m.marginMode = nil
}

// SetQuantityMode sets the "quantityMode" field.
func (m *StrategyMutation) SetQuantityMode(sm strategy.QuantityMode) {
	m.quantityMode = &sm
}

// QuantityMode returns the value of the "quantityMode" field in the mutation.
func (m *StrategyMutation) QuantityMode() (r strategy.QuantityMode, exists bool) {
	v := m.quantityMode
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantityMode returns the old "quantityMode" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldQuantityMode(ctx context.Context) (v strategy.QuantityMode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantityMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantityMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantityMode: %w", err)
	}
	return oldValue.QuantityMode, nil
}

// ResetQuantityMode resets all changes to the "quantityMode" field.
func (m *StrategyMutation) ResetQuantityMode() {
	m.quantityMode = nil
}

// SetPriceUpper sets the "priceUpper" field.
func (m *StrategyMutation) SetPriceUpper(d decimal.Decimal) {
	m.priceUpper = &d
}

// PriceUpper returns the value of the "priceUpper" field in the mutation.
func (m *StrategyMutation) PriceUpper() (r decimal.Decimal, exists bool) {
	v := m.priceUpper
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceUpper returns the old "priceUpper" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldPriceUpper(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriceUpper is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriceUpper requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceUpper: %w", err)
	}
	return oldValue.PriceUpper, nil
}

// ResetPriceUpper resets all changes to the "priceUpper" field.
func (m *StrategyMutation) ResetPriceUpper() {
	m.priceUpper = nil
}

// SetPriceLower sets the "priceLower" field.
func (m *StrategyMutation) SetPriceLower(d decimal.Decimal) {
	m.priceLower = &d
}

// PriceLower returns the value of the "priceLower" field in the mutation.
func (m *StrategyMutation) PriceLower() (r decimal.Decimal, exists bool) {
	v := m.priceLower
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceLower returns the old "priceLower" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldPriceLower(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriceLower is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriceLower requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceLower: %w", err)
	}
	return oldValue.PriceLower, nil
}

// ResetPriceLower resets all changes to the "priceLower" field.
func (m *StrategyMutation) ResetPriceLower() {
	m.priceLower = nil
}

// SetGridNum sets the "gridNum" field.
func (m *StrategyMutation) SetGridNum(i int) {
	m.gridNum = &i
	m.addgridNum = nil
}

// GridNum returns the value of the "gridNum" field in the mutation.
func (m *StrategyMutation) GridNum() (r int, exists bool) {
	v := m.gridNum
	if v == nil {
		return
	}
	return *v, true
}

// OldGridNum returns the old "gridNum" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldGridNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGridNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGridNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGridNum: %w", err)
	}
	return oldValue.GridNum, nil
}

// AddGridNum adds i to the "gridNum" field.
func (m *StrategyMutation) AddGridNum(i int) {
	if m.addgridNum != nil {
		*m.addgridNum += i
	} else {
		m.addgridNum = &i
	}
}

// AddedGridNum returns the value that was added to the "gridNum" field in this mutation.
func (m *StrategyMutation) AddedGridNum() (r int, exists bool) {
	v := m.addgridNum
	if v == nil {
		return
	}
	return *v, true
}

// ResetGridNum resets all changes to the "gridNum" field.
func (m *StrategyMutation) ResetGridNum() {
	m.gridNum = nil
	m.addgridNum = nil
}

// SetLeverage sets the "leverage" field.
func (m *StrategyMutation) SetLeverage(i int) {
	m.leverage = &i
	m.addleverage = nil
}

// Leverage returns the value of the "leverage" field in the mutation.
func (m *StrategyMutation) Leverage() (r int, exists bool) {
	v := m.leverage
	if v == nil {
		return
	}
	return *v, true
}

// OldLeverage returns the old "leverage" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldLeverage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeverage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeverage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeverage: %w", err)
	}
	return oldValue.Leverage, nil
}

// AddLeverage adds i to the "leverage" field.
func (m *StrategyMutation) AddLeverage(i int) {
	if m.addleverage != nil {
		*m.addleverage += i
	} else {
		m.addleverage = &i
	}
}

// AddedLeverage returns the value that was added to the "leverage" field in this mutation.
func (m *StrategyMutation) AddedLeverage() (r int, exists bool) {
	v := m.addleverage
	if v == nil {
		return
	}
	return *v, true
}

// ResetLeverage resets all changes to the "leverage" field.
func (m *StrategyMutation) ResetLeverage() {
	m.leverage = nil
	m.addleverage = nil
}

// SetInitialOrderSize sets the "initialOrderSize" field.
func (m *StrategyMutation) SetInitialOrderSize(d decimal.Decimal) {
	m.initialOrderSize = &d
}

// InitialOrderSize returns the value of the "initialOrderSize" field in the mutation.
func (m *StrategyMutation) InitialOrderSize() (r decimal.Decimal, exists bool) {
	v := m.initialOrderSize
	if v == nil {
		return
	}
	return *v, true
}

// OldInitialOrderSize returns the old "initialOrderSize" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldInitialOrderSize(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitialOrderSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitialOrderSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitialOrderSize: %w", err)
	}
	return oldValue.InitialOrderSize, nil
}

// ResetInitialOrderSize resets all changes to the "initialOrderSize" field.
func (m *StrategyMutation) ResetInitialOrderSize() {
	m.initialOrderSize = nil
}

// SetStopLossRatio sets the "stopLossRatio" field.
func (m *StrategyMutation) SetStopLossRatio(d decimal.Decimal) {
	m.stopLossRatio = &d
}

// StopLossRatio returns the value of the "stopLossRatio" field in the mutation.
func (m *StrategyMutation) StopLossRatio() (r decimal.Decimal, exists bool) {
	v := m.stopLossRatio
	if v == nil {
		return
	}
	return *v, true
}

// OldStopLossRatio returns the old "stopLossRatio" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldStopLossRatio(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStopLossRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStopLossRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStopLossRatio: %w", err)
	}
	return oldValue.StopLossRatio, nil
}

// ResetStopLossRatio resets all changes to the "stopLossRatio" field.
func (m *StrategyMutation) ResetStopLossRatio() {
	m.stopLossRatio = nil
}

// SetTakeProfitRatio sets the "takeProfitRatio" field.
func (m *StrategyMutation) SetTakeProfitRatio(d decimal.Decimal) {
	m.takeProfitRatio = &d
}

// TakeProfitRatio returns the value of the "takeProfitRatio" field in the mutation.
func (m *StrategyMutation) TakeProfitRatio() (r decimal.Decimal, exists bool) {
	v := m.takeProfitRatio
	if v == nil {
		return
	}
	return *v, true
}

// OldTakeProfitRatio returns the old "takeProfitRatio" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldTakeProfitRatio(ctx context.Context) (v decimal.Decimal, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTakeProfitRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTakeProfitRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTakeProfitRatio: %w", err)
	}
	return oldValue.TakeProfitRatio, nil
}

// ResetTakeProfitRatio resets all changes to the "takeProfitRatio" field.
func (m *StrategyMutation) ResetTakeProfitRatio() {
	m.takeProfitRatio = nil
}

// SetEnableAutoExit sets the "enableAutoExit" field.
func (m *StrategyMutation) SetEnableAutoExit(b bool) {
	m.enableAutoExit = &b
}

// EnableAutoExit returns the value of the "enableAutoExit" field in the mutation.
func (m *StrategyMutation) EnableAutoExit() (r bool, exists bool) {
	v := m.enableAutoExit
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableAutoExit returns the old "enableAutoExit" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldEnableAutoExit(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableAutoExit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableAutoExit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableAutoExit: %w", err)
	}
	return oldValue.EnableAutoExit, nil
}

// ResetEnableAutoExit resets all changes to the "enableAutoExit" field.
func (m *StrategyMutation) ResetEnableAutoExit() {
	m.enableAutoExit = nil
}

// SetEnablePushNotification sets the "enablePushNotification" field.
func (m *StrategyMutation) SetEnablePushNotification(b bool) {
	m.enablePushNotification = &b
}

// EnablePushNotification returns the value of the "enablePushNotification" field in the mutation.
func (m *StrategyMutation) EnablePushNotification() (r bool, exists bool) {
	v := m.enablePushNotification
	if v == nil {
		return
	}
	return *v, true
}

// OldEnablePushNotification returns the old "enablePushNotification" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldEnablePushNotification(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnablePushNotification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnablePushNotification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnablePushNotification: %w", err)
	}
	return oldValue.EnablePushNotification, nil
}

// ResetEnablePushNotification resets all changes to the "enablePushNotification" field.
func (m *StrategyMutation) ResetEnablePushNotification() {
	m.enablePushNotification = nil
}

// SetLastLowerThresholdAlertTime sets the "lastLowerThresholdAlertTime" field.
func (m *StrategyMutation) SetLastLowerThresholdAlertTime(t time.Time) {
	m.lastLowerThresholdAlertTime = &t
}

// LastLowerThresholdAlertTime returns the value of the "lastLowerThresholdAlertTime" field in the mutation.
func (m *StrategyMutation) LastLowerThresholdAlertTime() (r time.Time, exists bool) {
	v := m.lastLowerThresholdAlertTime
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLowerThresholdAlertTime returns the old "lastLowerThresholdAlertTime" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldLastLowerThresholdAlertTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLowerThresholdAlertTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLowerThresholdAlertTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLowerThresholdAlertTime: %w", err)
	}
	return oldValue.LastLowerThresholdAlertTime, nil
}

// ClearLastLowerThresholdAlertTime clears the value of the "lastLowerThresholdAlertTime" field.
func (m *StrategyMutation) ClearLastLowerThresholdAlertTime() {
	m.lastLowerThresholdAlertTime = nil
	m.clearedFields[strategy.FieldLastLowerThresholdAlertTime] = struct{}{}
}

// LastLowerThresholdAlertTimeCleared returns if the "lastLowerThresholdAlertTime" field was cleared in this mutation.
func (m *StrategyMutation) LastLowerThresholdAlertTimeCleared() bool {
	_, ok := m.clearedFields[strategy.FieldLastLowerThresholdAlertTime]
	return ok
}

// ResetLastLowerThresholdAlertTime resets all changes to the "lastLowerThresholdAlertTime" field.
func (m *StrategyMutation) ResetLastLowerThresholdAlertTime() {
	m.lastLowerThresholdAlertTime = nil
	delete(m.clearedFields, strategy.FieldLastLowerThresholdAlertTime)
}

// SetLastUpperThresholdAlertTime sets the "lastUpperThresholdAlertTime" field.
func (m *StrategyMutation) SetLastUpperThresholdAlertTime(t time.Time) {
	m.lastUpperThresholdAlertTime = &t
}

// LastUpperThresholdAlertTime returns the value of the "lastUpperThresholdAlertTime" field in the mutation.
func (m *StrategyMutation) LastUpperThresholdAlertTime() (r time.Time, exists bool) {
	v := m.lastUpperThresholdAlertTime
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpperThresholdAlertTime returns the old "lastUpperThresholdAlertTime" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldLastUpperThresholdAlertTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpperThresholdAlertTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpperThresholdAlertTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpperThresholdAlertTime: %w", err)
	}
	return oldValue.LastUpperThresholdAlertTime, nil
}

// ClearLastUpperThresholdAlertTime clears the value of the "lastUpperThresholdAlertTime" field.
func (m *StrategyMutation) ClearLastUpperThresholdAlertTime() {
	m.lastUpperThresholdAlertTime = nil
	m.clearedFields[strategy.FieldLastUpperThresholdAlertTime] = struct{}{}
}

// LastUpperThresholdAlertTimeCleared returns if the "lastUpperThresholdAlertTime" field was cleared in this mutation.
func (m *StrategyMutation) LastUpperThresholdAlertTimeCleared() bool {
	_, ok := m.clearedFields[strategy.FieldLastUpperThresholdAlertTime]
	return ok
}

// ResetLastUpperThresholdAlertTime resets all changes to the "lastUpperThresholdAlertTime" field.
func (m *StrategyMutation) ResetLastUpperThresholdAlertTime() {
	m.lastUpperThresholdAlertTime = nil
	delete(m.clearedFields, strategy.FieldLastUpperThresholdAlertTime)
}

// SetStatus sets the "status" field.
func (m *StrategyMutation) SetStatus(s strategy.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *StrategyMutation) Status() (r strategy.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldStatus(ctx context.Context) (v strategy.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *StrategyMutation) ResetStatus() {
	m.status = nil
}

// SetExchangeApiKey sets the "exchangeApiKey" field.
func (m *StrategyMutation) SetExchangeApiKey(s string) {
	m.exchangeApiKey = &s
}

// ExchangeApiKey returns the value of the "exchangeApiKey" field in the mutation.
func (m *StrategyMutation) ExchangeApiKey() (r string, exists bool) {
	v := m.exchangeApiKey
	if v == nil {
		return
	}
	return *v, true
}

// OldExchangeApiKey returns the old "exchangeApiKey" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldExchangeApiKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExchangeApiKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExchangeApiKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExchangeApiKey: %w", err)
	}
	return oldValue.ExchangeApiKey, nil
}

// ResetExchangeApiKey resets all changes to the "exchangeApiKey" field.
func (m *StrategyMutation) ResetExchangeApiKey() {
	m.exchangeApiKey = nil
}

// SetExchangeSecretKey sets the "exchangeSecretKey" field.
func (m *StrategyMutation) SetExchangeSecretKey(s string) {
	m.exchangeSecretKey = &s
}

// ExchangeSecretKey returns the value of the "exchangeSecretKey" field in the mutation.
func (m *StrategyMutation) ExchangeSecretKey() (r string, exists bool) {
	v := m.exchangeSecretKey
	if v == nil {
		return
	}
	return *v, true
}

// OldExchangeSecretKey returns the old "exchangeSecretKey" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldExchangeSecretKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExchangeSecretKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExchangeSecretKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExchangeSecretKey: %w", err)
	}
	return oldValue.ExchangeSecretKey, nil
}

// ResetExchangeSecretKey resets all changes to the "exchangeSecretKey" field.
func (m *StrategyMutation) ResetExchangeSecretKey() {
	m.exchangeSecretKey = nil
}

// SetExchangePassphrase sets the "exchangePassphrase" field.
func (m *StrategyMutation) SetExchangePassphrase(s string) {
	m.exchangePassphrase = &s
}

// ExchangePassphrase returns the value of the "exchangePassphrase" field in the mutation.
func (m *StrategyMutation) ExchangePassphrase() (r string, exists bool) {
	v := m.exchangePassphrase
	if v == nil {
		return
	}
	return *v, true
}

// OldExchangePassphrase returns the old "exchangePassphrase" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldExchangePassphrase(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExchangePassphrase is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExchangePassphrase requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExchangePassphrase: %w", err)
	}
	return oldValue.ExchangePassphrase, nil
}

// ResetExchangePassphrase resets all changes to the "exchangePassphrase" field.
func (m *StrategyMutation) ResetExchangePassphrase() {
	m.exchangePassphrase = nil
}

// Where appends a list predicates to the StrategyMutation builder.
func (m *StrategyMutation) Where(ps ...predicate.Strategy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StrategyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StrategyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Strategy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StrategyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StrategyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Strategy).
func (m *StrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StrategyMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m.create_time != nil {
		fields = append(fields, strategy.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, strategy.FieldUpdateTime)
	}
	if m.guid != nil {
		fields = append(fields, strategy.FieldGUID)
	}
	if m.owner != nil {
		fields = append(fields, strategy.FieldOwner)
	}
	if m.exchange != nil {
		fields = append(fields, strategy.FieldExchange)
	}
	if m.symbol != nil {
		fields = append(fields, strategy.FieldSymbol)
	}
	if m.account != nil {
		fields = append(fields, strategy.FieldAccount)
	}
	if m.mode != nil {
		fields = append(fields, strategy.FieldMode)
	}
	if m.marginMode != nil {
		fields = append(fields, strategy.FieldMarginMode)
	}
	if m.quantityMode != nil {
		fields = append(fields, strategy.FieldQuantityMode)
	}
	if m.priceUpper != nil {
		fields = append(fields, strategy.FieldPriceUpper)
	}
	if m.priceLower != nil {
		fields = append(fields, strategy.FieldPriceLower)
	}
	if m.gridNum != nil {
		fields = append(fields, strategy.FieldGridNum)
	}
	if m.leverage != nil {
		fields = append(fields, strategy.FieldLeverage)
	}
	if m.initialOrderSize != nil {
		fields = append(fields, strategy.FieldInitialOrderSize)
	}
	if m.stopLossRatio != nil {
		fields = append(fields, strategy.FieldStopLossRatio)
	}
	if m.takeProfitRatio != nil {
		fields = append(fields, strategy.FieldTakeProfitRatio)
	}
	if m.enableAutoExit != nil {
		fields = append(fields, strategy.FieldEnableAutoExit)
	}
	if m.enablePushNotification != nil {
		fields = append(fields, strategy.FieldEnablePushNotification)
	}
	if m.lastLowerThresholdAlertTime != nil {
		fields = append(fields, strategy.FieldLastLowerThresholdAlertTime)
	}
	if m.lastUpperThresholdAlertTime != nil {
		fields = append(fields, strategy.FieldLastUpperThresholdAlertTime)
	}
	if m.status != nil {
		fields = append(fields, strategy.FieldStatus)
	}
	if m.exchangeApiKey != nil {
		fields = append(fields, strategy.FieldExchangeApiKey)
	}
	if m.exchangeSecretKey != nil {
		fields = append(fields, strategy.FieldExchangeSecretKey)
	}
	if m.exchangePassphrase != nil {
		fields = append(fields, strategy.FieldExchangePassphrase)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case strategy.FieldCreateTime:
		return m.CreateTime()
	case strategy.FieldUpdateTime:
		return m.UpdateTime()
	case strategy.FieldGUID:
		return m.GUID()
	case strategy.FieldOwner:
		return m.Owner()
	case strategy.FieldExchange:
		return m.Exchange()
	case strategy.FieldSymbol:
		return m.Symbol()
	case strategy.FieldAccount:
		return m.Account()
	case strategy.FieldMode:
		return m.Mode()
	case strategy.FieldMarginMode:
		return m.MarginMode()
	case strategy.FieldQuantityMode:
		return m.QuantityMode()
	case strategy.FieldPriceUpper:
		return m.PriceUpper()
	case strategy.FieldPriceLower:
		return m.PriceLower()
	case strategy.FieldGridNum:
		return m.GridNum()
	case strategy.FieldLeverage:
		return m.Leverage()
	case strategy.FieldInitialOrderSize:
		return m.InitialOrderSize()
	case strategy.FieldStopLossRatio:
		return m.StopLossRatio()
	case strategy.FieldTakeProfitRatio:
		return m.TakeProfitRatio()
	case strategy.FieldEnableAutoExit:
		return m.EnableAutoExit()
	case strategy.FieldEnablePushNotification:
		return m.EnablePushNotification()
	case strategy.FieldLastLowerThresholdAlertTime:
		return m.LastLowerThresholdAlertTime()
	case strategy.FieldLastUpperThresholdAlertTime:
		return m.LastUpperThresholdAlertTime()
	case strategy.FieldStatus:
		return m.Status()
	case strategy.FieldExchangeApiKey:
		return m.ExchangeApiKey()
	case strategy.FieldExchangeSecretKey:
		return m.ExchangeSecretKey()
	case strategy.FieldExchangePassphrase:
		return m.ExchangePassphrase()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case strategy.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case strategy.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case strategy.FieldGUID:
		return m.OldGUID(ctx)
	case strategy.FieldOwner:
		return m.OldOwner(ctx)
	case strategy.FieldExchange:
		return m.OldExchange(ctx)
	case strategy.FieldSymbol:
		return m.OldSymbol(ctx)
	case strategy.FieldAccount:
		return m.OldAccount(ctx)
	case strategy.FieldMode:
		return m.OldMode(ctx)
	case strategy.FieldMarginMode:
		return m.OldMarginMode(ctx)
	case strategy.FieldQuantityMode:
		return m.OldQuantityMode(ctx)
	case strategy.FieldPriceUpper:
		return m.OldPriceUpper(ctx)
	case strategy.FieldPriceLower:
		return m.OldPriceLower(ctx)
	case strategy.FieldGridNum:
		return m.OldGridNum(ctx)
	case strategy.FieldLeverage:
		return m.OldLeverage(ctx)
	case strategy.FieldInitialOrderSize:
		return m.OldInitialOrderSize(ctx)
	case strategy.FieldStopLossRatio:
		return m.OldStopLossRatio(ctx)
	case strategy.FieldTakeProfitRatio:
		return m.OldTakeProfitRatio(ctx)
	case strategy.FieldEnableAutoExit:
		return m.OldEnableAutoExit(ctx)
	case strategy.FieldEnablePushNotification:
		return m.OldEnablePushNotification(ctx)
	case strategy.FieldLastLowerThresholdAlertTime:
		return m.OldLastLowerThresholdAlertTime(ctx)
	case strategy.FieldLastUpperThresholdAlertTime:
		return m.OldLastUpperThresholdAlertTime(ctx)
	case strategy.FieldStatus:
		return m.OldStatus(ctx)
	case strategy.FieldExchangeApiKey:
		return m.OldExchangeApiKey(ctx)
	case strategy.FieldExchangeSecretKey:
		return m.OldExchangeSecretKey(ctx)
	case strategy.FieldExchangePassphrase:
		return m.OldExchangePassphrase(ctx)
	}
	return nil, fmt.Errorf("unknown Strategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case strategy.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case strategy.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case strategy.FieldGUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGUID(v)
		return nil
	case strategy.FieldOwner:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case strategy.FieldExchange:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExchange(v)
		return nil
	case strategy.FieldSymbol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymbol(v)
		return nil
	case strategy.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case strategy.FieldMode:
		v, ok := value.(strategy.Mode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMode(v)
		return nil
	case strategy.FieldMarginMode:
		v, ok := value.(strategy.MarginMode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMarginMode(v)
		return nil
	case strategy.FieldQuantityMode:
		v, ok := value.(strategy.QuantityMode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantityMode(v)
		return nil
	case strategy.FieldPriceUpper:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceUpper(v)
		return nil
	case strategy.FieldPriceLower:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceLower(v)
		return nil
	case strategy.FieldGridNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGridNum(v)
		return nil
	case strategy.FieldLeverage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeverage(v)
		return nil
	case strategy.FieldInitialOrderSize:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitialOrderSize(v)
		return nil
	case strategy.FieldStopLossRatio:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStopLossRatio(v)
		return nil
	case strategy.FieldTakeProfitRatio:
		v, ok := value.(decimal.Decimal)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTakeProfitRatio(v)
		return nil
	case strategy.FieldEnableAutoExit:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableAutoExit(v)
		return nil
	case strategy.FieldEnablePushNotification:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnablePushNotification(v)
		return nil
	case strategy.FieldLastLowerThresholdAlertTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLowerThresholdAlertTime(v)
		return nil
	case strategy.FieldLastUpperThresholdAlertTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpperThresholdAlertTime(v)
		return nil
	case strategy.FieldStatus:
		v, ok := value.(strategy.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case strategy.FieldExchangeApiKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExchangeApiKey(v)
		return nil
	case strategy.FieldExchangeSecretKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExchangeSecretKey(v)
		return nil
	case strategy.FieldExchangePassphrase:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExchangePassphrase(v)
		return nil
	}
	return fmt.Errorf("unknown Strategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StrategyMutation) AddedFields() []string {
	var fields []string
	if m.addowner != nil {
		fields = append(fields, strategy.FieldOwner)
	}
	if m.addgridNum != nil {
		fields = append(fields, strategy.FieldGridNum)
	}
	if m.addleverage != nil {
		fields = append(fields, strategy.FieldLeverage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StrategyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case strategy.FieldOwner:
		return m.AddedOwner()
	case strategy.FieldGridNum:
		return m.AddedGridNum()
	case strategy.FieldLeverage:
		return m.AddedLeverage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case strategy.FieldOwner:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwner(v)
		return nil
	case strategy.FieldGridNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGridNum(v)
		return nil
	case strategy.FieldLeverage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLeverage(v)
		return nil
	}
	return fmt.Errorf("unknown Strategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(strategy.FieldLastLowerThresholdAlertTime) {
		fields = append(fields, strategy.FieldLastLowerThresholdAlertTime)
	}
	if m.FieldCleared(strategy.FieldLastUpperThresholdAlertTime) {
		fields = append(fields, strategy.FieldLastUpperThresholdAlertTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StrategyMutation) ClearField(name string) error {
	switch name {
	case strategy.FieldLastLowerThresholdAlertTime:
		m.ClearLastLowerThresholdAlertTime()
		return nil
	case strategy.FieldLastUpperThresholdAlertTime:
		m.ClearLastUpperThresholdAlertTime()
		return nil
	}
	return fmt.Errorf("unknown Strategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StrategyMutation) ResetField(name string) error {
	switch name {
	case strategy.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case strategy.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case strategy.FieldGUID:
		m.ResetGUID()
		return nil
	case strategy.FieldOwner:
		m.ResetOwner()
		return nil
	case strategy.FieldExchange:
		m.ResetExchange()
		return nil
	case strategy.FieldSymbol:
		m.ResetSymbol()
		return nil
	case strategy.FieldAccount:
		m.ResetAccount()
		return nil
	case strategy.FieldMode:
		m.ResetMode()
		return nil
	case strategy.FieldMarginMode:
		m.ResetMarginMode()
		return nil
	case strategy.FieldQuantityMode:
		m.ResetQuantityMode()
		return nil
	case strategy.FieldPriceUpper:
		m.ResetPriceUpper()
		return nil
	case strategy.FieldPriceLower:
		m.ResetPriceLower()
		return nil
	case strategy.FieldGridNum:
		m.ResetGridNum()
		return nil
	case strategy.FieldLeverage:
		m.ResetLeverage()
		return nil
	case strategy.FieldInitialOrderSize:
		m.ResetInitialOrderSize()
		return nil
	case strategy.FieldStopLossRatio:
		m.ResetStopLossRatio()
		return nil
	case strategy.FieldTakeProfitRatio:
		m.ResetTakeProfitRatio()
		return nil
	case strategy.FieldEnableAutoExit:
		m.ResetEnableAutoExit()
		return nil
	case strategy.FieldEnablePushNotification:
		m.ResetEnablePushNotification()
		return nil
	case strategy.FieldLastLowerThresholdAlertTime:
		m.ResetLastLowerThresholdAlertTime()
		return nil
	case strategy.FieldLastUpperThresholdAlertTime:
		m.ResetLastUpperThresholdAlertTime()
		return nil
	case strategy.FieldStatus:
		m.ResetStatus()
		return nil
	case strategy.FieldExchangeApiKey:
		m.ResetExchangeApiKey()
		return nil
	case strategy.FieldExchangeSecretKey:
		m.ResetExchangeSecretKey()
		return nil
	case strategy.FieldExchangePassphrase:
		m.ResetExchangePassphrase()
		return nil
	}
	return fmt.Errorf("unknown Strategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StrategyMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StrategyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StrategyMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StrategyMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Strategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StrategyMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Strategy edge %s", name)
}

// SyncProgressMutation represents an operation that mutates the SyncProgress nodes in the graph.
type SyncProgressMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	exchange      *string
	account       *string
	timestamp     *int64
	addtimestamp  *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SyncProgress, error)
	predicates    []predicate.SyncProgress
}

var _ ent.Mutation = (*SyncProgressMutation)(nil)

// syncprogressOption allows management of the mutation configuration using functional options.
type syncprogressOption func(*SyncProgressMutation)

// newSyncProgressMutation creates new mutation for the SyncProgress entity.
func newSyncProgressMutation(c config, op Op, opts ...syncprogressOption) *SyncProgressMutation {
	m := &SyncProgressMutation{
		config:        c,
		op:            op,
		typ:           TypeSyncProgress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSyncProgressID sets the ID field of the mutation.
func withSyncProgressID(id int) syncprogressOption {
	return func(m *SyncProgressMutation) {
		var (
			err   error
			once  sync.Once
			value *SyncProgress
		)
		m.oldValue = func(ctx context.Context) (*SyncProgress, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SyncProgress.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSyncProgress sets the old SyncProgress of the mutation.
func withSyncProgress(node *SyncProgress) syncprogressOption {
	return func(m *SyncProgressMutation) {
		m.oldValue = func(context.Context) (*SyncProgress, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SyncProgressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SyncProgressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SyncProgressMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SyncProgressMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SyncProgress.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SyncProgressMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SyncProgressMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SyncProgress entity.
// If the SyncProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncProgressMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SyncProgressMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SyncProgressMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SyncProgressMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SyncProgress entity.
// If the SyncProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncProgressMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SyncProgressMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetExchange sets the "exchange" field.
func (m *SyncProgressMutation) SetExchange(s string) {
	m.exchange = &s
}

// Exchange returns the value of the "exchange" field in the mutation.
func (m *SyncProgressMutation) Exchange() (r string, exists bool) {
	v := m.exchange
	if v == nil {
		return
	}
	return *v, true
}

// OldExchange returns the old "exchange" field's value of the SyncProgress entity.
// If the SyncProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncProgressMutation) OldExchange(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExchange is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExchange requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExchange: %w", err)
	}
	return oldValue.Exchange, nil
}

// ResetExchange resets all changes to the "exchange" field.
func (m *SyncProgressMutation) ResetExchange() {
	m.exchange = nil
}

// SetAccount sets the "account" field.
func (m *SyncProgressMutation) SetAccount(s string) {
	m.account = &s
}

// Account returns the value of the "account" field in the mutation.
func (m *SyncProgressMutation) Account() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccount returns the old "account" field's value of the SyncProgress entity.
// If the SyncProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncProgressMutation) OldAccount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccount: %w", err)
	}
	return oldValue.Account, nil
}

// ResetAccount resets all changes to the "account" field.
func (m *SyncProgressMutation) ResetAccount() {
	m.account = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *SyncProgressMutation) SetTimestamp(i int64) {
	m.timestamp = &i
	m.addtimestamp = nil
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *SyncProgressMutation) Timestamp() (r int64, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the SyncProgress entity.
// If the SyncProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SyncProgressMutation) OldTimestamp(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// AddTimestamp adds i to the "timestamp" field.
func (m *SyncProgressMutation) AddTimestamp(i int64) {
	if m.addtimestamp != nil {
		*m.addtimestamp += i
	} else {
		m.addtimestamp = &i
	}
}

// AddedTimestamp returns the value that was added to the "timestamp" field in this mutation.
func (m *SyncProgressMutation) AddedTimestamp() (r int64, exists bool) {
	v := m.addtimestamp
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *SyncProgressMutation) ResetTimestamp() {
	m.timestamp = nil
	m.addtimestamp = nil
}

// Where appends a list predicates to the SyncProgressMutation builder.
func (m *SyncProgressMutation) Where(ps ...predicate.SyncProgress) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SyncProgressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SyncProgressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SyncProgress, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SyncProgressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SyncProgressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SyncProgress).
func (m *SyncProgressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SyncProgressMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, syncprogress.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, syncprogress.FieldUpdateTime)
	}
	if m.exchange != nil {
		fields = append(fields, syncprogress.FieldExchange)
	}
	if m.account != nil {
		fields = append(fields, syncprogress.FieldAccount)
	}
	if m.timestamp != nil {
		fields = append(fields, syncprogress.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SyncProgressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case syncprogress.FieldCreateTime:
		return m.CreateTime()
	case syncprogress.FieldUpdateTime:
		return m.UpdateTime()
	case syncprogress.FieldExchange:
		return m.Exchange()
	case syncprogress.FieldAccount:
		return m.Account()
	case syncprogress.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SyncProgressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case syncprogress.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case syncprogress.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case syncprogress.FieldExchange:
		return m.OldExchange(ctx)
	case syncprogress.FieldAccount:
		return m.OldAccount(ctx)
	case syncprogress.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown SyncProgress field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SyncProgressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case syncprogress.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case syncprogress.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case syncprogress.FieldExchange:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExchange(v)
		return nil
	case syncprogress.FieldAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccount(v)
		return nil
	case syncprogress.FieldTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown SyncProgress field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SyncProgressMutation) AddedFields() []string {
	var fields []string
	if m.addtimestamp != nil {
		fields = append(fields, syncprogress.FieldTimestamp)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SyncProgressMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case syncprogress.FieldTimestamp:
		return m.AddedTimestamp()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SyncProgressMutation) AddField(name string, value ent.Value) error {
	switch name {
	case syncprogress.FieldTimestamp:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown SyncProgress numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SyncProgressMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SyncProgressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SyncProgressMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SyncProgress nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SyncProgressMutation) ResetField(name string) error {
	switch name {
	case syncprogress.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case syncprogress.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case syncprogress.FieldExchange:
		m.ResetExchange()
		return nil
	case syncprogress.FieldAccount:
		m.ResetAccount()
		return nil
	case syncprogress.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown SyncProgress field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SyncProgressMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SyncProgressMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SyncProgressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SyncProgressMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SyncProgressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SyncProgressMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SyncProgressMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SyncProgress unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SyncProgressMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SyncProgress edge %s", name)
}
