// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/fachebot/omni-grid-bot/internal/ent/strategy"
	"github.com/shopspring/decimal"
)

// Strategy is the model entity for the Strategy schema.
type Strategy struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// CreateTime holds the value of the "create_time" field.
	CreateTime time.Time `json:"create_time,omitempty"`
	// UpdateTime holds the value of the "update_time" field.
	UpdateTime time.Time `json:"update_time,omitempty"`
	// GUID holds the value of the "guid" field.
	GUID string `json:"guid,omitempty"`
	// Owner holds the value of the "owner" field.
	Owner int64 `json:"owner,omitempty"`
	// Exchange holds the value of the "exchange" field.
	Exchange string `json:"exchange,omitempty"`
	// Symbol holds the value of the "symbol" field.
	Symbol string `json:"symbol,omitempty"`
	// Account holds the value of the "account" field.
	Account string `json:"account,omitempty"`
	// Mode holds the value of the "mode" field.
	Mode strategy.Mode `json:"mode,omitempty"`
	// MarginMode holds the value of the "marginMode" field.
	MarginMode strategy.MarginMode `json:"marginMode,omitempty"`
	// QuantityMode holds the value of the "quantityMode" field.
	QuantityMode strategy.QuantityMode `json:"quantityMode,omitempty"`
	// PriceUpper holds the value of the "priceUpper" field.
	PriceUpper decimal.Decimal `json:"priceUpper,omitempty"`
	// PriceLower holds the value of the "priceLower" field.
	PriceLower decimal.Decimal `json:"priceLower,omitempty"`
	// GridNum holds the value of the "gridNum" field.
	GridNum int `json:"gridNum,omitempty"`
	// Leverage holds the value of the "leverage" field.
	Leverage int `json:"leverage,omitempty"`
	// InitialOrderSize holds the value of the "initialOrderSize" field.
	InitialOrderSize decimal.Decimal `json:"initialOrderSize,omitempty"`
	// StopLossRatio holds the value of the "stopLossRatio" field.
	StopLossRatio decimal.Decimal `json:"stopLossRatio,omitempty"`
	// TakeProfitRatio holds the value of the "takeProfitRatio" field.
	TakeProfitRatio decimal.Decimal `json:"takeProfitRatio,omitempty"`
	// SlippageBps holds the value of the "slippageBps" field.
	SlippageBps *int `json:"slippageBps,omitempty"`
	// EnableAutoExit holds the value of the "enableAutoExit" field.
	EnableAutoExit bool `json:"enableAutoExit,omitempty"`
	// EnablePushNotification holds the value of the "enablePushNotification" field.
	EnablePushNotification bool `json:"enablePushNotification,omitempty"`
	// EnablePushMatchedNotification holds the value of the "enablePushMatchedNotification" field.
	EnablePushMatchedNotification *bool `json:"enablePushMatchedNotification,omitempty"`
	// LastLowerThresholdAlertTime holds the value of the "lastLowerThresholdAlertTime" field.
	LastLowerThresholdAlertTime *time.Time `json:"lastLowerThresholdAlertTime,omitempty"`
	// LastUpperThresholdAlertTime holds the value of the "lastUpperThresholdAlertTime" field.
	LastUpperThresholdAlertTime *time.Time `json:"lastUpperThresholdAlertTime,omitempty"`
	// Status holds the value of the "status" field.
	Status strategy.Status `json:"status,omitempty"`
	// ExchangeApiKey holds the value of the "exchangeApiKey" field.
	ExchangeApiKey string `json:"exchangeApiKey,omitempty"`
	// ExchangeSecretKey holds the value of the "exchangeSecretKey" field.
	ExchangeSecretKey string `json:"exchangeSecretKey,omitempty"`
	// ExchangePassphrase holds the value of the "exchangePassphrase" field.
	ExchangePassphrase string `json:"exchangePassphrase,omitempty"`
	// StartTime holds the value of the "startTime" field.
	StartTime    *time.Time `json:"startTime,omitempty"`
	selectValues sql.SelectValues
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Strategy) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case strategy.FieldPriceUpper, strategy.FieldPriceLower, strategy.FieldInitialOrderSize, strategy.FieldStopLossRatio, strategy.FieldTakeProfitRatio:
			values[i] = new(decimal.Decimal)
		case strategy.FieldEnableAutoExit, strategy.FieldEnablePushNotification, strategy.FieldEnablePushMatchedNotification:
			values[i] = new(sql.NullBool)
		case strategy.FieldID, strategy.FieldOwner, strategy.FieldGridNum, strategy.FieldLeverage, strategy.FieldSlippageBps:
			values[i] = new(sql.NullInt64)
		case strategy.FieldGUID, strategy.FieldExchange, strategy.FieldSymbol, strategy.FieldAccount, strategy.FieldMode, strategy.FieldMarginMode, strategy.FieldQuantityMode, strategy.FieldStatus, strategy.FieldExchangeApiKey, strategy.FieldExchangeSecretKey, strategy.FieldExchangePassphrase:
			values[i] = new(sql.NullString)
		case strategy.FieldCreateTime, strategy.FieldUpdateTime, strategy.FieldLastLowerThresholdAlertTime, strategy.FieldLastUpperThresholdAlertTime, strategy.FieldStartTime:
			values[i] = new(sql.NullTime)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Strategy fields.
func (_m *Strategy) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case strategy.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			_m.ID = int(value.Int64)
		case strategy.FieldCreateTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field create_time", values[i])
			} else if value.Valid {
				_m.CreateTime = value.Time
			}
		case strategy.FieldUpdateTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field update_time", values[i])
			} else if value.Valid {
				_m.UpdateTime = value.Time
			}
		case strategy.FieldGUID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field guid", values[i])
			} else if value.Valid {
				_m.GUID = value.String
			}
		case strategy.FieldOwner:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field owner", values[i])
			} else if value.Valid {
				_m.Owner = value.Int64
			}
		case strategy.FieldExchange:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field exchange", values[i])
			} else if value.Valid {
				_m.Exchange = value.String
			}
		case strategy.FieldSymbol:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field symbol", values[i])
			} else if value.Valid {
				_m.Symbol = value.String
			}
		case strategy.FieldAccount:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field account", values[i])
			} else if value.Valid {
				_m.Account = value.String
			}
		case strategy.FieldMode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field mode", values[i])
			} else if value.Valid {
				_m.Mode = strategy.Mode(value.String)
			}
		case strategy.FieldMarginMode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field marginMode", values[i])
			} else if value.Valid {
				_m.MarginMode = strategy.MarginMode(value.String)
			}
		case strategy.FieldQuantityMode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field quantityMode", values[i])
			} else if value.Valid {
				_m.QuantityMode = strategy.QuantityMode(value.String)
			}
		case strategy.FieldPriceUpper:
			if value, ok := values[i].(*decimal.Decimal); !ok {
				return fmt.Errorf("unexpected type %T for field priceUpper", values[i])
			} else if value != nil {
				_m.PriceUpper = *value
			}
		case strategy.FieldPriceLower:
			if value, ok := values[i].(*decimal.Decimal); !ok {
				return fmt.Errorf("unexpected type %T for field priceLower", values[i])
			} else if value != nil {
				_m.PriceLower = *value
			}
		case strategy.FieldGridNum:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field gridNum", values[i])
			} else if value.Valid {
				_m.GridNum = int(value.Int64)
			}
		case strategy.FieldLeverage:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field leverage", values[i])
			} else if value.Valid {
				_m.Leverage = int(value.Int64)
			}
		case strategy.FieldInitialOrderSize:
			if value, ok := values[i].(*decimal.Decimal); !ok {
				return fmt.Errorf("unexpected type %T for field initialOrderSize", values[i])
			} else if value != nil {
				_m.InitialOrderSize = *value
			}
		case strategy.FieldStopLossRatio:
			if value, ok := values[i].(*decimal.Decimal); !ok {
				return fmt.Errorf("unexpected type %T for field stopLossRatio", values[i])
			} else if value != nil {
				_m.StopLossRatio = *value
			}
		case strategy.FieldTakeProfitRatio:
			if value, ok := values[i].(*decimal.Decimal); !ok {
				return fmt.Errorf("unexpected type %T for field takeProfitRatio", values[i])
			} else if value != nil {
				_m.TakeProfitRatio = *value
			}
		case strategy.FieldSlippageBps:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field slippageBps", values[i])
			} else if value.Valid {
				_m.SlippageBps = new(int)
				*_m.SlippageBps = int(value.Int64)
			}
		case strategy.FieldEnableAutoExit:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field enableAutoExit", values[i])
			} else if value.Valid {
				_m.EnableAutoExit = value.Bool
			}
		case strategy.FieldEnablePushNotification:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field enablePushNotification", values[i])
			} else if value.Valid {
				_m.EnablePushNotification = value.Bool
			}
		case strategy.FieldEnablePushMatchedNotification:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field enablePushMatchedNotification", values[i])
			} else if value.Valid {
				_m.EnablePushMatchedNotification = new(bool)
				*_m.EnablePushMatchedNotification = value.Bool
			}
		case strategy.FieldLastLowerThresholdAlertTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field lastLowerThresholdAlertTime", values[i])
			} else if value.Valid {
				_m.LastLowerThresholdAlertTime = new(time.Time)
				*_m.LastLowerThresholdAlertTime = value.Time
			}
		case strategy.FieldLastUpperThresholdAlertTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field lastUpperThresholdAlertTime", values[i])
			} else if value.Valid {
				_m.LastUpperThresholdAlertTime = new(time.Time)
				*_m.LastUpperThresholdAlertTime = value.Time
			}
		case strategy.FieldStatus:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[i])
			} else if value.Valid {
				_m.Status = strategy.Status(value.String)
			}
		case strategy.FieldExchangeApiKey:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field exchangeApiKey", values[i])
			} else if value.Valid {
				_m.ExchangeApiKey = value.String
			}
		case strategy.FieldExchangeSecretKey:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field exchangeSecretKey", values[i])
			} else if value.Valid {
				_m.ExchangeSecretKey = value.String
			}
		case strategy.FieldExchangePassphrase:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field exchangePassphrase", values[i])
			} else if value.Valid {
				_m.ExchangePassphrase = value.String
			}
		case strategy.FieldStartTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field startTime", values[i])
			} else if value.Valid {
				_m.StartTime = new(time.Time)
				*_m.StartTime = value.Time
			}
		default:
			_m.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Strategy.
// This includes values selected through modifiers, order, etc.
func (_m *Strategy) Value(name string) (ent.Value, error) {
	return _m.selectValues.Get(name)
}

// Update returns a builder for updating this Strategy.
// Note that you need to call Strategy.Unwrap() before calling this method if this Strategy
// was returned from a transaction, and the transaction was committed or rolled back.
func (_m *Strategy) Update() *StrategyUpdateOne {
	return NewStrategyClient(_m.config).UpdateOne(_m)
}

// Unwrap unwraps the Strategy entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (_m *Strategy) Unwrap() *Strategy {
	_tx, ok := _m.config.driver.(*txDriver)
	if !ok {
		panic("ent: Strategy is not a transactional entity")
	}
	_m.config.driver = _tx.drv
	return _m
}

// String implements the fmt.Stringer.
func (_m *Strategy) String() string {
	var builder strings.Builder
	builder.WriteString("Strategy(")
	builder.WriteString(fmt.Sprintf("id=%v, ", _m.ID))
	builder.WriteString("create_time=")
	builder.WriteString(_m.CreateTime.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("update_time=")
	builder.WriteString(_m.UpdateTime.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("guid=")
	builder.WriteString(_m.GUID)
	builder.WriteString(", ")
	builder.WriteString("owner=")
	builder.WriteString(fmt.Sprintf("%v", _m.Owner))
	builder.WriteString(", ")
	builder.WriteString("exchange=")
	builder.WriteString(_m.Exchange)
	builder.WriteString(", ")
	builder.WriteString("symbol=")
	builder.WriteString(_m.Symbol)
	builder.WriteString(", ")
	builder.WriteString("account=")
	builder.WriteString(_m.Account)
	builder.WriteString(", ")
	builder.WriteString("mode=")
	builder.WriteString(fmt.Sprintf("%v", _m.Mode))
	builder.WriteString(", ")
	builder.WriteString("marginMode=")
	builder.WriteString(fmt.Sprintf("%v", _m.MarginMode))
	builder.WriteString(", ")
	builder.WriteString("quantityMode=")
	builder.WriteString(fmt.Sprintf("%v", _m.QuantityMode))
	builder.WriteString(", ")
	builder.WriteString("priceUpper=")
	builder.WriteString(fmt.Sprintf("%v", _m.PriceUpper))
	builder.WriteString(", ")
	builder.WriteString("priceLower=")
	builder.WriteString(fmt.Sprintf("%v", _m.PriceLower))
	builder.WriteString(", ")
	builder.WriteString("gridNum=")
	builder.WriteString(fmt.Sprintf("%v", _m.GridNum))
	builder.WriteString(", ")
	builder.WriteString("leverage=")
	builder.WriteString(fmt.Sprintf("%v", _m.Leverage))
	builder.WriteString(", ")
	builder.WriteString("initialOrderSize=")
	builder.WriteString(fmt.Sprintf("%v", _m.InitialOrderSize))
	builder.WriteString(", ")
	builder.WriteString("stopLossRatio=")
	builder.WriteString(fmt.Sprintf("%v", _m.StopLossRatio))
	builder.WriteString(", ")
	builder.WriteString("takeProfitRatio=")
	builder.WriteString(fmt.Sprintf("%v", _m.TakeProfitRatio))
	builder.WriteString(", ")
	if v := _m.SlippageBps; v != nil {
		builder.WriteString("slippageBps=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	builder.WriteString("enableAutoExit=")
	builder.WriteString(fmt.Sprintf("%v", _m.EnableAutoExit))
	builder.WriteString(", ")
	builder.WriteString("enablePushNotification=")
	builder.WriteString(fmt.Sprintf("%v", _m.EnablePushNotification))
	builder.WriteString(", ")
	if v := _m.EnablePushMatchedNotification; v != nil {
		builder.WriteString("enablePushMatchedNotification=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	if v := _m.LastLowerThresholdAlertTime; v != nil {
		builder.WriteString("lastLowerThresholdAlertTime=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := _m.LastUpperThresholdAlertTime; v != nil {
		builder.WriteString("lastUpperThresholdAlertTime=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	builder.WriteString("status=")
	builder.WriteString(fmt.Sprintf("%v", _m.Status))
	builder.WriteString(", ")
	builder.WriteString("exchangeApiKey=")
	builder.WriteString(_m.ExchangeApiKey)
	builder.WriteString(", ")
	builder.WriteString("exchangeSecretKey=")
	builder.WriteString(_m.ExchangeSecretKey)
	builder.WriteString(", ")
	builder.WriteString("exchangePassphrase=")
	builder.WriteString(_m.ExchangePassphrase)
	builder.WriteString(", ")
	if v := _m.StartTime; v != nil {
		builder.WriteString("startTime=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteByte(')')
	return builder.String()
}

// Strategies is a parsable slice of Strategy.
type Strategies []*Strategy
